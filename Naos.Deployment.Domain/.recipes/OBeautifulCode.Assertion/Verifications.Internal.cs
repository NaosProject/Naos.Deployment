// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Verifications.Internal.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using global::System;
    using global::System.Collections;
    using global::System.Collections.Generic;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Globalization;
    using global::System.Linq;
    using global::System.Text.RegularExpressions;
    using OBeautifulCode.String.Recipes;
    using OBeautifulCode.Type.Recipes;

    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "A generalized assertion library is going to require lots of types.")]
#if !OBeautifulCodeAssertionSolution
    internal
#else
    public
#endif
    static partial class Verifications
    {
        private static void BeNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (!ReferenceEquals(verifiableItem.ItemValue, null))
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeNullExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeNullExceptionMessageSuffix);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentNullException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void BeTrueInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldThrow = ReferenceEquals(verifiableItem.ItemValue, null) || ((bool)verifiableItem.ItemValue != true);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeTrueExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeTrueInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldNotThrow = ReferenceEquals(verifiableItem.ItemValue, null) || ((bool)verifiableItem.ItemValue == false);

            if (!shouldNotThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeTrueExceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeFalseInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldThrow = ReferenceEquals(verifiableItem.ItemValue, null) || (bool)verifiableItem.ItemValue;

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeFalseExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeFalseInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldNotThrow = ReferenceEquals(verifiableItem.ItemValue, null) || (bool)verifiableItem.ItemValue;

            if (!shouldNotThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeFalseExceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeTrueWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            var shouldThrow = (bool)verifiableItem.ItemValue != true;

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeTrueWhenNotNullExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeTrueWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            var shouldNotThrow = (bool)verifiableItem.ItemValue == false;

            if (!shouldNotThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeTrueWhenNotNullExceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeFalseWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            var shouldThrow = (bool)verifiableItem.ItemValue;

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeFalseWhenNotNullExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeFalseWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            var shouldNotThrow = (bool)verifiableItem.ItemValue;

            if (!shouldNotThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeFalseWhenNotNullExceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeNullNorWhiteSpaceInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var shouldThrow = string.IsNullOrWhiteSpace((string)verifiableItem.ItemValue);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeNullNorWhiteSpaceExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeNullOrNotWhiteSpaceInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldThrow = !ReferenceEquals(verifiableItem.ItemValue, null) && string.IsNullOrWhiteSpace((string)verifiableItem.ItemValue);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeNullOrNotWhiteSpaceExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeEmptyGuidInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldThrow = ReferenceEquals(verifiableItem.ItemValue, null) || ((Guid)verifiableItem.ItemValue != Guid.Empty);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeEmptyGuidExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeEmptyGuidInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldThrow = (!ReferenceEquals(verifiableItem.ItemValue, null)) && ((Guid)verifiableItem.ItemValue == Guid.Empty);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeEmptyGuidExceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1820:TestForEmptyStringsUsingStringLength", Justification = "string.IsNullOrEmpty does not work here")]
        private static void BeEmptyStringInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldThrow = (string)verifiableItem.ItemValue != string.Empty;

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeEmptyStringExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1820:TestForEmptyStringsUsingStringLength", Justification = "string.IsNullOrEmpty does not work here")]
        private static void NotBeEmptyStringInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldThrow = (string)verifiableItem.ItemValue == string.Empty;

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeEmptyStringExceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void BeEmptyEnumerableInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var valueAsEnumerable = verifiableItem.ItemValue as IEnumerable;

            var elementCount = GetElementCount(valueAsEnumerable);

            var shouldThrow = elementCount != 0;

            if (shouldThrow)
            {
                var contextualInfo = string.Format(CultureInfo.InvariantCulture, EnumerableElementCountContextualInfo, elementCount);

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeEmptyEnumerableExceptionMessageSuffix, contextualInfo: contextualInfo);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void NotBeEmptyEnumerableInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            NotBeEmptyEnumerableInternalInternal(assertionTracker, verification, verifiableItem, NotBeEmptyEnumerableExceptionMessageSuffix);
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void NotBeEmptyEnumerableWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeEmptyEnumerableInternalInternal(assertionTracker, verification, verifiableItem, NotBeEmptyEnumerableWhenNotNullExceptionMessageSuffix);
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void BeEmptyDictionaryInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var valueAsDictionary = verifiableItem.ItemValue as IDictionary;

            // ReSharper disable once PossibleNullReferenceException
            var shouldThrow = valueAsDictionary.Count != 0;

            if (shouldThrow)
            {
                var contextualInfo = string.Format(CultureInfo.InvariantCulture, DictionaryCountContextualInfo, valueAsDictionary.Count);

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeEmptyDictionaryExceptionMessageSuffix, contextualInfo: contextualInfo);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void NotBeEmptyDictionaryInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            NotBeEmptyDictionaryInternalInternal(assertionTracker, verification, verifiableItem, NotBeEmptyDictionaryExceptionMessageSuffix);
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void NotBeEmptyDictionaryWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeEmptyDictionaryInternalInternal(assertionTracker, verification, verifiableItem, NotBeEmptyDictionaryWhenNotNullExceptionMessageSuffix);
        }

        private static void ContainSomeNullElementsInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var valueAsEnumerable = verifiableItem.ItemValue as IEnumerable;

            var shouldThrow = true;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var unused in valueAsEnumerable)
            {
                if (ReferenceEquals(unused, null))
                {
                    shouldThrow = false;
                    break;
                }
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, ContainSomeNullElementsExceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotContainAnyNullElementsInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            NotContainAnyNullElementsInternalInternal(assertionTracker, verification, verifiableItem, NotContainAnyNullElementsExceptionMessageSuffix);
        }

        private static void NotContainAnyNullElementsWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotContainAnyNullElementsInternalInternal(assertionTracker, verification, verifiableItem, NotContainAnyNullElementsWhenNotNullExceptionMessageSuffix);
        }

        private static void ContainSomeKeyValuePairsWithNullValueInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var valueAsEnumerable = verifiableItem.ItemValue as IEnumerable;

            var shouldThrow = true;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var keyValuePair in valueAsEnumerable)
            {
                if (ReferenceEquals(((dynamic)keyValuePair).Value, null))
                {
                    shouldThrow = false;
                    break;
                }
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, ContainSomeKeyValuePairsWithNullValueExceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotContainAnyKeyValuePairsWithNullValueInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            NotContainAnyKeyValuePairsWithNullValueInternalInternal(assertionTracker, verification, verifiableItem, NotContainAnyKeyValuePairsWithNullValueExceptionMessageSuffix);
        }

        private static void NotContainAnyKeyValuePairsWithNullValueWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotContainAnyKeyValuePairsWithNullValueInternalInternal(assertionTracker, verification, verifiableItem, NotContainAnyKeyValuePairsWithNullValueWhenNotNullExceptionMessageSuffix);
        }

        private static void ContainKeyInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            ContainKeyInternalInternal(assertionTracker, verification, verifiableItem, ContainKeyExceptionMessageSuffix);
        }

        private static void NotContainKeyInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            NotContainKeyInternalInternal(assertionTracker, verification, verifiableItem, NotContainKeyExceptionMessageSuffix);
        }

        private static void ContainKeyWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            ContainKeyInternalInternal(assertionTracker, verification, verifiableItem, ContainKeyWhenNotNullExceptionMessageSuffix);
        }

        private static void NotContainKeyWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotContainKeyInternalInternal(assertionTracker, verification, verifiableItem, NotContainKeyWhenNotNullExceptionMessageSuffix);
        }

        private static void BeDefaultInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var defaultValue = GetDefaultValue(verifiableItem.ItemType);

            var shouldThrow = !AreEqual(verifiableItem.ItemType, verifiableItem.ItemValue, defaultValue);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsEqualToMethodology, verifiableItem.ItemType.ToStringReadable());

                var contextualInfo = string.Format(CultureInfo.InvariantCulture, DefaultValueContextualInfo, defaultValue.ToStringInErrorMessage());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeDefaultExceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo, contextualInfo: contextualInfo);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeDefaultInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var defaultValue = GetDefaultValue(verifiableItem.ItemType);

            var shouldThrow = AreEqual(verifiableItem.ItemType, verifiableItem.ItemValue, defaultValue);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsEqualToMethodology, verifiableItem.ItemType.ToStringReadable());

                var contextualInfo = string.Format(CultureInfo.InvariantCulture, DefaultValueContextualInfo, defaultValue.ToStringInErrorMessage());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeDefaultExceptionMessageSuffix, methodologyInfo: methodologyInfo, contextualInfo: contextualInfo);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeLessThanInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            BeLessThanInternalInternal(assertionTracker, verification, verifiableItem, BeLessThanExceptionMessageSuffix);
        }

        private static void NotBeLessThanInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeLessThanInternalInternal(assertionTracker, verification, verifiableItem, NotBeLessThanExceptionMessageSuffix);
        }

        private static void BeGreaterThanInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            BeGreaterThanInternalInternal(assertionTracker, verification, verifiableItem, BeGreaterThanExceptionMessageSuffix);
        }

        private static void NotBeGreaterThanInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeGreaterThanInternalInternal(assertionTracker, verification, verifiableItem, NotBeGreaterThanExceptionMessageSuffix);
        }

        private static void BeLessThanOrEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            BeLessThanOrEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeLessThanOrEqualToExceptionMessageSuffix);
        }

        private static void NotBeLessThanOrEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeLessThanOrEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeLessThanOrEqualToExceptionMessageSuffix);
        }

        private static void BeGreaterThanOrEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            BeGreaterThanOrEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeGreaterThanOrEqualToExceptionMessageSuffix);
        }

        private static void NotBeGreaterThanOrEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeGreaterThanOrEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeGreaterThanOrEqualToExceptionMessageSuffix);
        }

        private static void BeLessThanWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            BeLessThanInternalInternal(assertionTracker, verification, verifiableItem, BeLessThanWhenNotNullExceptionMessageSuffix);
        }

        private static void NotBeLessThanWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeLessThanInternalInternal(assertionTracker, verification, verifiableItem, NotBeLessThanWhenNotNullExceptionMessageSuffix);
        }

        private static void BeGreaterThanWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            BeGreaterThanInternalInternal(assertionTracker, verification, verifiableItem, BeGreaterThanWhenNotNullExceptionMessageSuffix);
        }

        private static void NotBeGreaterThanWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeGreaterThanInternalInternal(assertionTracker, verification, verifiableItem, NotBeGreaterThanWhenNotNullExceptionMessageSuffix);
        }

        private static void BeLessThanOrEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            BeLessThanOrEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeLessThanOrEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void NotBeLessThanOrEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeLessThanOrEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeLessThanOrEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void BeGreaterThanOrEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            BeGreaterThanOrEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeGreaterThanOrEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void NotBeGreaterThanOrEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeGreaterThanOrEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeGreaterThanOrEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void BeEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            BeEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeEqualToExceptionMessageSuffix);
        }

        private static void NotBeEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeEqualToExceptionMessageSuffix);
        }

        private static void BeEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            BeEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void NotBeEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void BeSequenceEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            BeSequenceEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeSequenceEqualToExceptionMessageSuffix);
        }

        private static void NotBeSequenceEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeSequenceEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeSequenceEqualToExceptionMessageSuffix);
        }

        private static void BeSequenceEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            BeSequenceEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeSequenceEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void NotBeSequenceEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeSequenceEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeSequenceEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void BeUnorderedEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            BeUnorderedEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeUnorderedEqualToExceptionMessageSuffix);
        }

        private static void NotBeUnorderedEqualToInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeUnorderedEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeUnorderedEqualToExceptionMessageSuffix);
        }

        private static void BeUnorderedEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            BeUnorderedEqualToInternalInternal(assertionTracker, verification, verifiableItem, BeUnorderedEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void NotBeUnorderedEqualToWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeUnorderedEqualToInternalInternal(assertionTracker, verification, verifiableItem, NotBeUnorderedEqualToWhenNotNullExceptionMessageSuffix);
        }

        private static void BeElementInInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            BeElementInInternalInternal(assertionTracker, verification, verifiableItem, BeElementInExceptionMessageSuffix);
        }

        private static void NotBeElementInInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeElementInInternalInternal(assertionTracker, verification, verifiableItem, NotBeElementInExceptionMessageSuffix);
        }

        private static void BeElementInWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            BeElementInInternalInternal(assertionTracker, verification, verifiableItem, BeElementInWhenNotNullExceptionMessageSuffix);
        }

        private static void NotBeElementInWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotBeElementInInternalInternal(assertionTracker, verification, verifiableItem, NotBeElementInWhenNotNullExceptionMessageSuffix);
        }

        private static void BeInRangeInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            ThrowIfMalformedRange(verification.VerificationParameters);

            var shouldThrow = (CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) == CompareOutcome.Value1LessThanValue2) ||
                              (CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[1].Value) == CompareOutcome.Value1GreaterThanValue2);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeInRangeExceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotBeInRangeInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            ThrowIfMalformedRange(verification.VerificationParameters);

            var shouldThrow = (CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) != CompareOutcome.Value1LessThanValue2) &&
                              (CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[1].Value) != CompareOutcome.Value1GreaterThanValue2);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeInRangeExceptionMessageSuffix, Include.FailingValue, methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void ContainElementInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            ContainElementInternalInternal(assertionTracker, verification, verifiableItem, ContainElementExceptionMessageSuffix);
        }

        private static void NotContainElementInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            NotContainElementInternalInternal(assertionTracker, verification, verifiableItem, NotContainElementExceptionMessageSuffix);
        }

        private static void ContainElementWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            ContainElementInternalInternal(assertionTracker, verification, verifiableItem, ContainElementWhenNotNullExceptionMessageSuffix);
        }

        private static void NotContainElementWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            NotContainElementInternalInternal(assertionTracker, verification, verifiableItem, NotContainElementWhenNotNullExceptionMessageSuffix);
        }

        private static void ContainOnlyDistinctElementsInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            ContainOnlyDistinctElementsInternalInternal(assertionTracker, verification, verifiableItem, ContainOnlyDistinctElementsExceptionMessageSuffix);
        }

        private static void ContainOnlyDistinctElementsWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            ContainOnlyDistinctElementsInternalInternal(assertionTracker, verification, verifiableItem, ContainOnlyDistinctElementsWhenNotNullExceptionMessageSuffix);
        }

        private static void BeAlphabeticInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var otherAllowedCharacters = (IReadOnlyCollection<char>)verification.VerificationParameters[0].Value;

            var stringValue = (string)verifiableItem.ItemValue;

            var shouldThrow = !stringValue.IsAlphabetic(otherAllowedCharacters);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeAlphabeticExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeAlphanumericInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var otherAllowedCharacters = (IReadOnlyCollection<char>)verification.VerificationParameters[0].Value;

            var stringValue = (string)verifiableItem.ItemValue;

            var shouldThrow = !stringValue.IsAlphanumeric(otherAllowedCharacters);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeAlphanumericExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeAsciiPrintableInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var treatNewLineAsPrintable = (bool)verification.VerificationParameters[0].Value;

            var stringValue = (string)verifiableItem.ItemValue;

            if (treatNewLineAsPrintable)
            {
                stringValue = stringValue.Replace(Environment.NewLine, string.Empty);
            }

            var shouldThrow = stringValue.Any(_ => ((int)_ < 32) || ((int)_ > 126));

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeAsciiPrintableExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeMatchedByRegexInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var regex = (Regex)verification.VerificationParameters[0].Value;

            var stringValue = (string)verifiableItem.ItemValue;

            var shouldThrow = !regex.IsMatch(stringValue);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeMatchedByRegexExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeMatchedByRegexInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var regex = (Regex)verification.VerificationParameters[0].Value;

            var stringValue = (string)verifiableItem.ItemValue;

            var shouldThrow = regex.IsMatch(stringValue);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeMatchedByRegexExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Globalization", "CA1307:SpecifyStringComparison", MessageId = "System.String.StartsWith(System.String)", Justification = "User can specify whether to verify with comparisonType or not.")]
        private static void StartWithInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var subjectValue = (string)verifiableItem.ItemValue;
            var comparisonValue = (string)verification.VerificationParameters[0].Value;
            var comparisonType = (StringComparison?)verification.VerificationParameters[1].Value;

            var shouldThrow = comparisonType == null
                ? !subjectValue.StartsWith(comparisonValue)
                : !subjectValue.StartsWith(comparisonValue, (StringComparison)comparisonType);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, StartWithExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Globalization", "CA1307:SpecifyStringComparison", MessageId = "System.String.StartsWith(System.String)", Justification = "User can specify whether to verify with comparisonType or not.")]
        private static void NotStartWithInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var subjectValue = (string)verifiableItem.ItemValue;
            var comparisonValue = (string)verification.VerificationParameters[0].Value;
            var comparisonType = (StringComparison?)verification.VerificationParameters[1].Value;

            var shouldThrow = comparisonType == null
                ? subjectValue.StartsWith(comparisonValue)
                : subjectValue.StartsWith(comparisonValue, (StringComparison)comparisonType);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotStartWithExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Globalization", "CA1307:SpecifyStringComparison", MessageId = "System.String.EndsWith(System.String)", Justification = "User can specify whether to verify with comparisonType or not.")]
        private static void EndWithInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var subjectValue = (string)verifiableItem.ItemValue;
            var comparisonValue = (string)verification.VerificationParameters[0].Value;
            var comparisonType = (StringComparison?)verification.VerificationParameters[1].Value;

            var shouldThrow = comparisonType == null
                ? !subjectValue.EndsWith(comparisonValue)
                : !subjectValue.EndsWith(comparisonValue, (StringComparison)comparisonType);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, EndWithExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Globalization", "CA1307:SpecifyStringComparison", MessageId = "System.String.EndsWith(System.String)", Justification = "User can specify whether to verify with comparisonType or not.")]
        private static void NotEndWithInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var subjectValue = (string)verifiableItem.ItemValue;
            var comparisonValue = (string)verification.VerificationParameters[0].Value;
            var comparisonType = (StringComparison?)verification.VerificationParameters[1].Value;

            var shouldThrow = comparisonType == null
                ? subjectValue.EndsWith(comparisonValue)
                : subjectValue.EndsWith(comparisonValue, (StringComparison)comparisonType);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotEndWithExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeSameReferenceAsInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldThrow = !object.ReferenceEquals(verifiableItem.ItemValue, verification.VerificationParameters[0].Value);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeSameReferenceAsExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeSameReferenceAsInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            var shouldThrow = object.ReferenceEquals(verifiableItem.ItemValue, verification.VerificationParameters[0].Value);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeSameReferenceAsExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void ContainStringInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var subjectValue = (string)verifiableItem.ItemValue;
            var comparisonValue = (string)verification.VerificationParameters[0].Value;

            var shouldThrow = !subjectValue.Contains(comparisonValue);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, ContainStringExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotContainStringInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var subjectValue = (string)verifiableItem.ItemValue;
            var comparisonValue = (string)verification.VerificationParameters[0].Value;

            var shouldThrow = subjectValue.Contains(comparisonValue);

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotContainStringExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void HaveCountInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var valueAsEnumerable = verifiableItem.ItemValue as IEnumerable;

            var expectedCount = (int)verification.VerificationParameters[0].Value;

            var actualCount = GetElementCount(valueAsEnumerable);

            var shouldThrow = actualCount != expectedCount;

            if (shouldThrow)
            {
                var contextualInfo = string.Format(CultureInfo.InvariantCulture, EnumerableElementCountContextualInfo, actualCount);

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, HaveCountExceptionMessageSuffix, contextualInfo: contextualInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotHaveCountInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var valueAsEnumerable = verifiableItem.ItemValue as IEnumerable;

            var unexpectedCount = (int)verification.VerificationParameters[0].Value;

            var actualCount = GetElementCount(valueAsEnumerable);

            var shouldThrow = actualCount == unexpectedCount;

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotHaveCountExceptionMessageSuffix);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void BeOfTypeInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var expectedType = (Type)verification.VerificationParameters[0].Value;

            // Note that we are NOT using verifiableItem.ValueType, which is the declared type.
            // In this case we need the actual type of the value.
            var actualType = verifiableItem.ItemValue.GetType();

            var shouldThrow = actualType != expectedType;

            if (shouldThrow)
            {
                var contextualInfo = string.Format(CultureInfo.InvariantCulture, verifiableItem.ItemIsElementInEnumerable ? ElementTypeContextualInfo : SubjectTypeContextualInfo, actualType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeOfTypeExceptionMessageSuffix, contextualInfo: contextualInfo);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeOfTypeInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var unexpectedType = (Type)verification.VerificationParameters[0].Value;

            // Note that we are NOT using verifiableItem.ValueType, which is the declared type.
            // In this case we need the actual type of the value.
            var actualType = verifiableItem.ItemValue.GetType();

            var shouldThrow = actualType == unexpectedType;

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeOfTypeExceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeAssignableToTypeInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var assignableType = (Type)verification.VerificationParameters[0].Value;

            var treatUnboundGenericAsAssignableTo = (verification.VerificationParameters.Count == 2) && (bool)verification.VerificationParameters[1].Value;

            // Note that we are NOT using verifiableItem.ValueType, which is the declared type.
            // In this case we need the actual type of the value.
            var actualType = verifiableItem.ItemValue.GetType();

            var shouldThrow = !actualType.IsAssignableTo(assignableType, treatUnboundGenericAsAssignableTo);

            if (shouldThrow)
            {
                var contextualInfo = string.Format(CultureInfo.InvariantCulture, verifiableItem.ItemIsElementInEnumerable ? ElementTypeContextualInfo : SubjectTypeContextualInfo, actualType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeAssignableToTypeExceptionMessageSuffix, contextualInfo: contextualInfo);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeAssignableToTypeInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var unassignableType = (Type)verification.VerificationParameters[0].Value;

            var treatUnboundGenericAsAssignableTo = (verification.VerificationParameters.Count == 2) && (bool)verification.VerificationParameters[1].Value;

            // Note that we are NOT using verifiableItem.ValueType, which is the declared type.
            // In this case we need the actual type of the value.
            var actualType = verifiableItem.ItemValue.GetType();

            var shouldThrow = actualType.IsAssignableTo(unassignableType, treatUnboundGenericAsAssignableTo);

            if (shouldThrow)
            {
                var contextualInfo = string.Format(CultureInfo.InvariantCulture, verifiableItem.ItemIsElementInEnumerable ? ElementTypeContextualInfo : SubjectTypeContextualInfo, actualType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeAssignableToTypeExceptionMessageSuffix, contextualInfo: contextualInfo);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeValidEmailAddressInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var subjectValue = (string)verifiableItem.ItemValue;

            var shouldThrow = !subjectValue.IsValidEmailAddress();

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, BeValidEmailAddressExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotBeValidEmailAddressInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var subjectValue = (string)verifiableItem.ItemValue;

            var shouldThrow = subjectValue.IsValidEmailAddress();

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, NotBeValidEmailAddressExceptionMessageSuffix, Include.FailingValue);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeUtcDateTimeInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            BeUtcDateTimeInternalInternal(assertionTracker, verification, verifiableItem, BeUtcDateTimeExceptionMessageSuffix);
        }

        private static void BeUtcDateTimeWhenNotNullInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem)
        {
            if (ReferenceEquals(verifiableItem.ItemValue, null))
            {
                return;
            }

            BeUtcDateTimeInternalInternal(assertionTracker, verification, verifiableItem, BeUtcDateTimeWhenNotNullExceptionMessageSuffix);
        }

        private static void BeLessThanInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) != CompareOutcome.Value1LessThanValue2;

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotBeLessThanInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) == CompareOutcome.Value1LessThanValue2;

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void BeGreaterThanInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) != CompareOutcome.Value1GreaterThanValue2;

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotBeGreaterThanInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) == CompareOutcome.Value1GreaterThanValue2;

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void BeLessThanOrEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) == CompareOutcome.Value1GreaterThanValue2;

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotBeLessThanOrEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) != CompareOutcome.Value1GreaterThanValue2;

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void BeGreaterThanOrEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) == CompareOutcome.Value1LessThanValue2;

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotBeGreaterThanOrEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = CompareUsingDefaultComparer(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value) != CompareOutcome.Value1LessThanValue2;

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingDefaultComparerMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }
        
        private static void BeEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = !AreEqual(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsEqualToMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotBeEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var shouldThrow = AreEqual(verifiableItem.ItemType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsEqualToMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void BeSequenceEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var elementType = verifiableItem.ItemType.GetClosedEnumerableElementType();

            var shouldThrow = !AreSequenceEqual(elementType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value, verification.VerificationParameters[1].Value);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsSequenceEqualToMethodology, elementType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = ArgumentExceptionKind.ArgumentException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotBeSequenceEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var elementType = verifiableItem.ItemType.GetClosedEnumerableElementType();

            var shouldThrow = AreSequenceEqual(elementType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value, verification.VerificationParameters[1].Value);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsSequenceEqualToMethodology, elementType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = ArgumentExceptionKind.ArgumentException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void BeUnorderedEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var elementType = verifiableItem.ItemType.GetClosedEnumerableElementType();

            var shouldThrow = !AreUnorderedEqual(elementType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value, verification.VerificationParameters[1].Value);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsUnorderedEqualToMethodology, elementType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = ArgumentExceptionKind.ArgumentException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotBeUnorderedEqualToInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var elementType = verifiableItem.ItemType.GetClosedEnumerableElementType();

            var shouldThrow = AreUnorderedEqual(elementType, verifiableItem.ItemValue, verification.VerificationParameters[0].Value, verification.VerificationParameters[1].Value);

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsUnorderedEqualToMethodology, elementType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = ArgumentExceptionKind.ArgumentException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void BeElementInInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var comparisonValues = (IEnumerable)verification.VerificationParameters[0].Value;

            var shouldThrow = true;

            foreach (var comparisonValue in comparisonValues)
            {
                if (AreEqual(verifiableItem.ItemType, verifiableItem.ItemValue, comparisonValue))
                {
                    shouldThrow = false;

                    break;
                }
            }

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsEqualToMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void NotBeElementInInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var comparisonValues = (IEnumerable)verification.VerificationParameters[0].Value;

            var shouldThrow = false;

            foreach (var comparisonValue in comparisonValues)
            {
                if (AreEqual(verifiableItem.ItemType, verifiableItem.ItemValue, comparisonValue))
                {
                    shouldThrow = true;

                    break;
                }
            }

            if (shouldThrow)
            {
                var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsEqualToMethodology, verifiableItem.ItemType.ToStringReadable());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, Include.FailingValue, methodologyInfo: methodologyInfo);

                var argumentExceptionKind = verifiableItem.ItemIsElementInEnumerable
                    ? ArgumentExceptionKind.ArgumentException
                    : ArgumentExceptionKind.ArgumentOutOfRangeException;

                var exception = BuildException(assertionTracker, verification, exceptionMessage, argumentExceptionKind);

                throw exception;
            }
        }

        private static void ContainElementInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var valueAsEnumerable = (IEnumerable)verifiableItem.ItemValue;
            var searchForItem = verification.VerificationParameters[0].Value;
            var elementType = verification.VerificationParameters[0].ParameterType;

            foreach (var element in valueAsEnumerable)
            {
                if (AreEqual(elementType, element, searchForItem))
                {
                    return;
                }
            }

            var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsEqualToMethodology, elementType.ToStringReadable());

            var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, methodologyInfo: methodologyInfo);

            var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

            throw exception;
        }

        private static void NotContainElementInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var valueAsEnumerable = (IEnumerable)verifiableItem.ItemValue;
            var searchForItem = verification.VerificationParameters[0].Value;
            var elementType = verification.VerificationParameters[0].ParameterType;

            foreach (var element in valueAsEnumerable)
            {
                if (AreEqual(elementType, element, searchForItem))
                {
                    var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsEqualToMethodology, elementType.ToStringReadable());

                    var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, methodologyInfo: methodologyInfo);

                    var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                    throw exception;
                }
            }
        }

        private static void ContainOnlyDistinctElementsInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var valueAsEnumerable = (IEnumerable)verifiableItem.ItemValue;
            var elementType = valueAsEnumerable.GetType().GetClosedEnumerableElementType();

            var distinctSet = new List<object>();

            foreach (var element in valueAsEnumerable)
            {
                foreach (var distinctElement in distinctSet)
                {
                    if (AreEqual(elementType, element, distinctElement))
                    {
                        var methodologyInfo = string.Format(CultureInfo.InvariantCulture, UsingIsEqualToMethodology, elementType.ToStringReadable());

                        var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, methodologyInfo: methodologyInfo);

                        var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                        throw exception;
                    }
                }

                distinctSet.Add(element);
            }
        }

        private static void ContainKeyInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var valueAsDictionary = (IDictionary)verifiableItem.ItemValue;
            var searchForKey = verification.VerificationParameters[0].Value;

            if (valueAsDictionary.Contains(searchForKey))
            {
                return;
            }

            var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix);

            var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

            throw exception;
        }

        private static void NotContainKeyInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var valueAsDictionary = (IDictionary)verifiableItem.ItemValue;
            var searchForKey = verification.VerificationParameters[0].Value;

            if (valueAsDictionary.Contains(searchForKey))
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void BeUtcDateTimeInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var valueAsDateTime = (DateTime)verifiableItem.ItemValue;

            if (valueAsDateTime.Kind != DateTimeKind.Utc)
            {
                var contextualInfo = string.Format(CultureInfo.InvariantCulture, DateTimeKindContextualInfo, valueAsDateTime.Kind);

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, contextualInfo: contextualInfo);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotContainAnyNullElementsInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var valueAsEnumerable = verifiableItem.ItemValue as IEnumerable;

            var shouldThrow = false;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var unused in valueAsEnumerable)
            {
                if (ReferenceEquals(unused, null))
                {
                    shouldThrow = true;
                    break;
                }
            }

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        private static void NotContainAnyKeyValuePairsWithNullValueInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var valueAsEnumerable = verifiableItem.ItemValue as IEnumerable;

            var shouldThrow = false;

            object offendingKey = null;

            // ReSharper disable once PossibleNullReferenceException
            foreach (var keyValuePair in valueAsEnumerable)
            {
                if (ReferenceEquals(((dynamic)keyValuePair).Value, null))
                {
                    shouldThrow = true;

                    offendingKey = ((dynamic)keyValuePair).Key;

                    break;
                }
            }

            if (shouldThrow)
            {
                var contextualInfo = string.Format(CultureInfo.InvariantCulture, DictionaryKeyExampleContextualInfo, offendingKey.ToStringInErrorMessage());

                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix, contextualInfo: contextualInfo);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void NotBeEmptyEnumerableInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            var valueAsEnumerable = verifiableItem.ItemValue as IEnumerable;

            var elementCount = GetElementCount(valueAsEnumerable);

            var shouldThrow = elementCount == 0;

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "unused", Justification = "Cannot iterate without a local")]
        private static void NotBeEmptyDictionaryInternalInternal(
            AssertionTracker assertionTracker,
            Verification verification,
            VerifiableItem verifiableItem,
            string exceptionMessageSuffix)
        {
            NotBeNullInternal(assertionTracker, verification, verifiableItem);

            var valueAsDictionary = verifiableItem.ItemValue as IDictionary;

            // ReSharper disable once PossibleNullReferenceException
            var shouldThrow = valueAsDictionary.Count == 0;

            if (shouldThrow)
            {
                var exceptionMessage = BuildVerificationFailedExceptionMessage(assertionTracker, verification, verifiableItem, exceptionMessageSuffix);

                var exception = BuildException(assertionTracker, verification, exceptionMessage, ArgumentExceptionKind.ArgumentException);

                throw exception;
            }
        }
    }
}
