// --------------------------------------------------------------------------------------------------------------------
// <copyright file="CamelStrictConstructorContractResolver.cs">
//     Copyright (c) 2016. All rights reserved. Licensed under the MIT license. See LICENSE file in
//     the project root for full license information.
// </copyright>
// <auto-generated>
// Sourced from NuGet package. Will be overwritten with package update except in Spritely.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Spritely.Recipes
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Reflection;

    using Newtonsoft.Json;
    using Newtonsoft.Json.Serialization;

    /// <summary>
    /// Resolves member mappings for a type using camel casing property names.
    /// Also requires that constructor parameters are defined in the json string
    /// when deserializing, for types with non-default constructors. 
    /// </summary>
    /// <remarks>
    /// See <a href="https://stackoverflow.com/questions/37416233/json-net-should-not-use-default-values-for-constructor-parameters-should-use-de"/>
    /// </remarks>
#if !SpritelyRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Spritely.Recipes", "See package version number")]
#pragma warning disable 0436
#endif
    internal class CamelStrictConstructorContractResolver
        : CamelCasePropertyNamesContractResolver
    {
        private static readonly CamelStrictConstructorContractResolver ContractResolverInstance
            = new CamelStrictConstructorContractResolver();

        /// <summary>
        /// As of 7.0.1, Json.NET suggests using a static instance for "stateless" contract resolvers, for performance reasons.
        /// <a href="http://www.newtonsoft.com/json/help/html/ContractResolver.htm"/>
        /// <a href="http://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_Serialization_DefaultContractResolver__ctor_1.htm"/>
        /// "Use the parameterless constructor and cache instances of the contract resolver within your application for optimal performance."
        /// Also, <a href="https://stackoverflow.com/questions/33557737/does-json-net-cache-types-serialization-information"/>
        /// </summary>
        public static CamelStrictConstructorContractResolver Instance
        {
            get
            {
                return ContractResolverInstance;
            }
        }

        /// <inheritdoc />
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", MessageId = "0", Justification = "This method is largely a copy-paste of the method it overrides, and that method does not validate arguments.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", MessageId = "1", Justification = "This method is largely a copy-paste of the method it overrides, and that method does not validate arguments.")]
        protected override IList<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties)
        {
            var constructorParameters = constructor.GetParameters();

            JsonPropertyCollection parameterCollection = new JsonPropertyCollection(constructor.DeclaringType);

            foreach (ParameterInfo parameterInfo in constructorParameters)
            {
                JsonProperty matchingMemberProperty = (parameterInfo.Name != null) ? memberProperties.GetClosestMatchProperty(parameterInfo.Name) : null;

                // Constructor type must be assignable from property type.
                // Note that this is the only difference between this method and the method it overrides in DefaultContractResolver.
                // In DefaultContractResolver, the types must match exactly.
                if (matchingMemberProperty != null && !parameterInfo.ParameterType.IsAssignableFrom(matchingMemberProperty.PropertyType))
                {
                    matchingMemberProperty = null;
                }

                if (matchingMemberProperty != null || parameterInfo.Name != null)
                {
                    JsonProperty property = CreatePropertyFromConstructorParameter(matchingMemberProperty, parameterInfo);

                    if (property != null)
                    {
                        parameterCollection.AddProperty(property);
                    }
                }
            }

            return parameterCollection;
        }

        /// <inheritdoc />
        protected override JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo)
        {
            if (matchingMemberProperty == null)
            {
                string message = parameterInfo == null
                                     ? "All constructor parameters are required; found one that is not specified in json"
                                     : string.Format(
                                         CultureInfo.InvariantCulture,
                                         "This constructor parameter is required, but not specified in json: {0}",
                                         parameterInfo.Name);
                throw new JsonSerializationException(message);
            }

            var property = base.CreatePropertyFromConstructorParameter(matchingMemberProperty, parameterInfo);

            if (property != null)
            {
                var required = matchingMemberProperty.Required;
                if (required == Required.Default)
                {
                    if (matchingMemberProperty.PropertyType != null &&
                        matchingMemberProperty.PropertyType.IsValueType &&
                        Nullable.GetUnderlyingType(matchingMemberProperty.PropertyType) == null)
                    {
                        required = Required.Always;
                    }
                    else
                    {
                        // this does NOT mean that the parameter is not required
                        // the property must be defined in JSON, but can be null
                        required = Required.AllowNull;
                    }

                    property.Required = matchingMemberProperty.Required = required;
                }
            }

            return property;
        }
    }
#if !SpritelyRecipesProject
#pragma warning restore 0436
#endif
}
