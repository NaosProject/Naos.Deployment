// --------------------------------------------------------------------------------------------------------------------
// <copyright file="InheritedTypeJsonConverter.cs">
//     Copyright (c) 2016. All rights reserved. Licensed under the MIT license. See LICENSE file in
//     the project root for full license information.
// </copyright>
// <auto-generated>
// Sourced from NuGet package. Will be overwritten with package update except in Spritely.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Spritely.Recipes
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Threading;

    using Newtonsoft.Json;
    using Newtonsoft.Json.Linq;

    /// <summary>
    /// Insprired by: http://StackOverflow.com/a/17247339/1442829
    /// --- This requires the base type it's used on to declare all of the types it might use... ---
    /// Use Bindable Attribute to match a derived class based on the class given to the serializer
    /// Selected class will be the first class to match all properties in the json object.
    /// </summary>
#if !SpritelyRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Spritely.Recipes", "See package version number")]
#pragma warning disable 0436
#endif
    internal abstract partial class InheritedTypeJsonConverter : JsonConverter
    {
        protected readonly string TypeTokenName = "$concreteType";

        private readonly ConcurrentDictionary<Type, IReadOnlyCollection<Type>> allChildTypes =
            new ConcurrentDictionary<Type, IReadOnlyCollection<Type>>();

        protected IEnumerable<Type> GetChildTypes(Type type)
        {
            if (!allChildTypes.ContainsKey(type))
            {
                var childTypes = AppDomain.CurrentDomain.GetAssemblies()
                    .Where(a => !a.FullName.Contains("Microsoft.GeneratedCode"))
                    .SelectMany(
                        a =>
                        {
                            try
                            {
                                return a.GetTypes();
                            }
                            catch (ReflectionTypeLoadException)
                            {
                                return new Type[] { };
                            }
                        })
                    .Where(
                        t =>
                            t != null && t.IsClass && !t.IsAbstract && !t.IsGenericTypeDefinition && t != type && type.IsAssignableFrom(t))
                    .ToList();

                allChildTypes.AddOrUpdate(type, t => childTypes, (t, cts) => childTypes);
            }

            return allChildTypes[type];
        }

        protected static BindableAttribute GetBindableAttribute(Type objectType)
        {
            // If multiple types in the hierarchy have a Bindable attribute, only one is returned.
            // If the type is Bindable then that attribute is returned.  Otherwise, the attribute on
            // the type that is closest to the current type, going up the hierarchy, is returned.
            // A single type cannot specify Bindable multiple times, the compiler throws with CS0579.
            var attribute = Attribute.GetCustomAttributes(objectType, typeof(BindableAttribute)).OfType<BindableAttribute>().SingleOrDefault();
            return attribute;
        }

        protected static bool IsTwoWayBindable(BindableAttribute bindableAttribute)
        {
            var bindingDirectionIsTwoWay = bindableAttribute.Direction == BindingDirection.TwoWay;
            return bindingDirectionIsTwoWay;
        }
    }

    /// <summary>
    /// An <see cref="InheritedTypeJsonConverter"/> that handles reads/deserialization.
    /// </summary>
#if !SpritelyRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Spritely.Recipes", "See package version number")]
#pragma warning disable 0436
#endif
    internal partial class InheritedTypeReaderJsonConverter : InheritedTypeJsonConverter
    {
        /// <inheritdoc />
        public override bool CanRead
        {
            get
            {
                return true;
            }
        }

        /// <inheritdoc />
        public override bool CanWrite
        {
            get
            {
                return false;
            }
        }

        /// <inheritdoc />
        public override bool CanConvert(Type objectType)
        {
            var bindableAttribute = GetBindableAttribute(objectType);
            if (bindableAttribute == null)
            {
                return false;
            }

            // When de-serializing, objectType will be whatever type the caller wants to de-serialize into.
            // If the type has children, then we want to use our implementation of ReadJson to pick the
            // right child, otherwise there is no ambiguity about which type to create and json.net can just handle it.
            var childTypes = GetChildTypes(objectType);
            return childTypes.Any();
        }

        /// <inheritdoc />
        /// <remarks>
        /// - Methodology
        ///   - Is the type Two-Way bindable and has the type of the object written into the json?  If yes then strip
        ///     out the type information and ask Json.net to deserialize into that type.  If not then...
        ///   - Get all child types of the specified type.
        ///   - Filter to child types where every 1st level JSON property is either a public (accessor is public)
        ///     property or a public field of the child type, using case-insensitive matching.  Child types passing
        ///     this filter are called 'candidates'.
        ///   - If there are no candidates, then throw.
        ///   - For all candidates, ask the serializer to deserialize the JSON as the candidate type.  Catch and 
        ///     ignore exceptions when attempting to deserialize.  If only one candidate successfully deserializes
        ///     then return the deserialized object.
        ///   - If more than one candidate successfully deserializes, then filter to candidates whose public 
        ///     properites and fields are all 1st level JSON properties, using case-insensitive matching. We call
        ///     this "strict matching."  If only one candidate has a strict match, return the corresponding
        ///     deserialized object.  Otherwise, throw.
        /// - Using the serializer to deserialize enables the method to support types with constructors,
        ///   which JSON.net does well out-of-the-box and which would be cumbersome to emulate.
        /// - This method does not consider > 1st level JSON properties to determine candidates.  In other words,
        ///   it is not matching on the fields/properties of the child's fields/properties (e.g. the match is done 
        ///   on Dog.Owner, not Dog.Owner.OwnersAddress).  The issue is that that kind of matching would require
        ///   complex logic.  For example, Strings have properties such as Length which would need to be ignored 
        ///   when reflecting.  Similarly, all fields/properties of value-types would need to be ignored.  There 
        ///   are likely other corner-cases.  To keep things simple, if the 1st level properties match the type's
        ///   properties and fields, by name, we hand-off the problem to the serializer and let it throw if
        ///   there is some incompatability deep in the field/property hierarchy.
        /// - This method does not consider the type of objects containted within JSON arrays to determine
        ///   candidates.  This is difficult because JSON arrays can contain a mix of types (just likes .net 
        ///   objects) and every element would have to be deserialized and matched against the child's IEnumerable
        ///   type and undoubtedly complexity would arise from dealing with generics and the vast implementations
        ///   of IEnumerable.  Like the bullet above, we simply hand-off the problem to the serializer.
        /// - If properties or fields are removed from a child type after it has been serialized, then the JSON
        ///   will not deserialize properly because that child type will no longer be a candidate.  If, however,
        ///   properties or fields are added to the child type, then the child type will continue to be a
        ///   candidate for the serialized JSON.
        /// - If the user serializes private or internal fields/properties, then this method will not work because
        ///   it only looks for public fields/properties.  We cannot bank on the JSON having been serialized by
        ///   the same serializer passed to this method.  Even if we could, the serializer is so highly 
        ///   configurable that it would be difficult to determine whether or which internal or private fields
        ///   or properties are serialized.
        /// - It's OK if the JSON is serialized with NullValueHandling.Ignore because the candidate filter tries
        ///   to find all JSON properties in child type's properties/fields, and not vice-versa.  However, depending
        ///   on how permissive the serializer's Contract Resolver is, those candidates may or may not be able to
        ///   be deserialized.  For example, if constructor parameters are required and a particular parameter is
        ///   excluded from the JSON, then that type cannot be deserialized.
        /// </remarks>
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader == null)
            {
                throw new ArgumentNullException("reader");
            }

            if (serializer == null)
            {
                throw new ArgumentNullException("serializer");
            }

            if (reader.TokenType == JsonToken.Null)
            {
                return null;
            }

            var jsonObject = JObject.Load(reader);
            var jsonProperties = new HashSet<string>(GetProperties(jsonObject), StringComparer.OrdinalIgnoreCase);

            // if two-way bindable then then type should be written into the json
            // if it's not then fallback on the typical strategy
            var bindableAttribute = GetBindableAttribute(objectType);
            if (IsTwoWayBindable(bindableAttribute) && jsonProperties.Contains(TypeTokenName))
            {
                return ReadUsingTypeSpecifiedInJson(serializer, jsonObject);
            }

            var childTypes = GetChildTypes(objectType);
            var candidateChildTypes = GetCandidateChildTypes(childTypes, jsonProperties);
            var deserializedChildren = DeserializeCandidates(candidateChildTypes, serializer, jsonObject).ToList();

            if (deserializedChildren.Count == 0)
            {
                throw new JsonSerializationException(
                    string.Format(CultureInfo.InvariantCulture, "Unable to deserialize to type {0}, value: {1}", objectType, jsonObject));
            }

            CandidateChildType matchedChild = null;
            if (deserializedChildren.Count == 1)
            {
                matchedChild = deserializedChildren.Single();
            }
            else if (deserializedChildren.Count > 1)
            {
                matchedChild = SelectBestChildUsingStrictPropertyMatching(deserializedChildren, jsonObject, jsonProperties);
            }

            return matchedChild.DeserializedObject;
        }

        private object ReadUsingTypeSpecifiedInJson(JsonSerializer serializer, JObject jsonObject)
        {
            var concreteType = jsonObject[TypeTokenName].ToString();
            jsonObject.Remove(TypeTokenName);
            var objectType = Type.GetType(concreteType);
            var reader = jsonObject.CreateReader();
            var result = serializer.Deserialize(reader, objectType);
            return result;
        }

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            throw new NotSupportedException("This is a read-only converter.");
        }

        private class CandidateChildType
        {
            public Type Type { get; set; }

            public HashSet<string> PropertiesAndFields { get; set; }

            public object DeserializedObject { get; set; }
        }

        private static IReadOnlyCollection<string> GetProperties(JToken node)
        {
            var result = new List<string>();

            if (node.Type == JTokenType.Object)
            {
                result.AddRange(node.Children<JProperty>().Select(child => child.Name));
            }

            return result;
        }

        private static IEnumerable<CandidateChildType> GetCandidateChildTypes(IEnumerable<Type> childTypes, HashSet<string> jsonProperties)
        {
            var candidateChildTypes = new List<CandidateChildType>();
            foreach (var childType in childTypes)
            {
                var childTypeProperties = childType.GetProperties().Select(t => t.Name).ToList();
                var childTypeFields = childType.GetFields().Select(t => t.Name).ToList();
                var childTypePropertiesAndFields = new HashSet<string>(
                    childTypeProperties.Concat(childTypeFields),
                    StringComparer.OrdinalIgnoreCase);
                if (jsonProperties.All(p => childTypePropertiesAndFields.Contains(p)))
                {
                    var candidateChildType = new CandidateChildType
                    {
                        Type = childType,
                        PropertiesAndFields = childTypePropertiesAndFields
                    };
                    candidateChildTypes.Add(candidateChildType);
                }
            }

            return candidateChildTypes;
        }

        private static IEnumerable<CandidateChildType> DeserializeCandidates(IEnumerable<CandidateChildType> candidateChildTypes, JsonSerializer serializer, JObject jsonObject)
        {
            foreach (var candidateChildType in candidateChildTypes)
            {
                object deserializedObject = null;

                try
                {
                    deserializedObject = serializer.Deserialize(jsonObject.CreateReader(), candidateChildType.Type);
                }
                catch (JsonException)
                {
                }
                catch (ArgumentException)
                {
                }

                if (deserializedObject != null)
                {
                    yield return
                        new CandidateChildType
                        {
                            Type = candidateChildType.Type,
                            PropertiesAndFields = candidateChildType.PropertiesAndFields,
                            DeserializedObject = deserializedObject
                        };
                }
            }
        }

        private static CandidateChildType SelectBestChildUsingStrictPropertyMatching(IEnumerable<CandidateChildType> candidateChildTypes, JObject jsonObject, HashSet<string> jsonProperties)
        {
            candidateChildTypes = candidateChildTypes.ToList();
            var strictCandidates =
                    candidateChildTypes.Where(cct => cct.PropertiesAndFields.All(pf => jsonProperties.Contains(pf)))
                        .ToList();

            if (strictCandidates.Count != 1)
            {
                var typesToReportInException = strictCandidates.Count == 0 ? candidateChildTypes : strictCandidates;
                var matchingTypes =
                    typesToReportInException.Select(_ => _.Type.FullName)
                        .Aggregate((running, current) => running + " | " + current);
                throw new JsonSerializationException(
                    string.Format(CultureInfo.InvariantCulture, "The json string can be deserialized into multiple types: {0}, value: {1}", matchingTypes, jsonObject));
            }

            return strictCandidates.Single();
        }
    }

    /// <summary>
    /// An <see cref="InheritedTypeJsonConverter"/> that handles writes/serialization.
    /// </summary>
#if !SpritelyRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Spritely.Recipes", "See package version number")]
#pragma warning disable 0436
#endif
    internal partial class InheritedTypeWriterJsonConverter : InheritedTypeJsonConverter
    {
        private static readonly ThreadLocal<bool> WriteJsonCalled = new ThreadLocal<bool>(() => false);

        /// <inheritdoc />
        public override bool CanRead
        {
            get
            {
                return false;
            }
        }

        /// <inheritdoc />
        public override bool CanWrite
        {
            get
            {
                return true;
            }
        }

        /// <inheritdoc />
        public override bool CanConvert(Type objectType)
        {
            // WriteJson needs to use the JsonSerializer passed to the method so that
            // the various settings in the serializer are utilized for writing.
            // Using the serializer as-is, however, will cause infinite recursion because
            // this Converter is utilized by the serializer.  If we modify the serializer
            // to remove this converter, it will affect all other consumers of the serializer.
            // Also, the object to serialize might contain types that require this converter.
            // The only way to manage this to store some state when WriteJson is called,
            // detect that state here, and tell json.net that we cannot convert the type.
            if (WriteJsonCalled.Value)
            {
                WriteJsonCalled.Value = false;
                return false;
            }

            var bindableAttribute = GetBindableAttribute(objectType);
            if (bindableAttribute == null)
            {
                return false;
            }

            // Two-way instructs the converter to add the name of the type to the JSON payload
            // when serializing.  This is sometimes required to disambiguate types when de-serializing.
            // Sometimes, multiple types have the same named properties and share an abstract parent.  De-serializing
            // the JSON into the abstract parent won't work without some extra information to determine which
            // of those multiple types to create.  In this case, we want to call our implementation of WriteJson.
            var isTwoWayBindable = IsTwoWayBindable(bindableAttribute);
            return isTwoWayBindable;
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            throw new NotSupportedException("This is a write-only converter");
        }

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value == null)
            {
                throw new ArgumentNullException("value");
            }

            string typeName = value.GetType().FullName + ", " + value.GetType().Assembly.GetName().Name;
            WriteJsonCalled.Value = true;
            var jo = JObject.FromObject(value, serializer);
            jo.Add(TypeTokenName, typeName);
            jo.WriteTo(writer);
        }
    }
#if !SpritelyRecipesProject
#pragma warning restore 0436
#endif
}
