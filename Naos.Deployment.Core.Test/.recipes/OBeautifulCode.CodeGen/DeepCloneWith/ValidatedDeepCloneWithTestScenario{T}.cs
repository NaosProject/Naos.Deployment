// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ValidatedDeepCloneWithTestScenario{T}.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.CodeGen.ModelObject.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.CodeGen.ModelObject.Recipes
{
    using global::System;
    using global::System.Linq;
    using global::System.Reflection;

    using OBeautifulCode.Assertion.Recipes;
    using OBeautifulCode.Reflection.Recipes;
    using OBeautifulCode.Type.Recipes;

    /// <summary>
    /// Specifies a scenario for testing DeepCloneWith methods.
    /// </summary>
    /// <typeparam name="T">The type of the object being tested.</typeparam>
#if !OBeautifulCodeCodeGenSolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.CodeGen.ModelObject.Recipes", "See package version number")]
    internal
#else
    public
#endif
    class ValidatedDeepCloneWithTestScenario<T>
        where T : class
    {
        /// <summary>
        /// Initializes a new instances of the <see cref="ValidatedDeepCloneWithTestScenario{T}"/> class.
        /// </summary>
        /// <param name="id">The identifier of the scenario.</param>
        /// <param name="withPropertyName">The name of the property whose value is provided in the DeepCloneWith call.  All other properties will be deep cloned EXCEPT this one.</param>
        /// <param name="systemUnderTestDeepCloneWithValueFunc">A func that returns the object being tested and a value to deep clone that object with.</param>
        public ValidatedDeepCloneWithTestScenario(
            string id,
            string withPropertyName,
            Func<SystemUnderTestDeepCloneWithValue<T>> systemUnderTestDeepCloneWithValueFunc)
        {
            new { id }.AsTest().Must().NotBeNullNorWhiteSpace();

            new { withPropertyName }.AsTest().Must().NotBeNullNorWhiteSpace(id);

            T systemUnderTest = null;
            object withValue = null;
            MethodInfo deepCloneWithMethod = null;

            if (withPropertyName != DeepCloneWithTestScenario.ForceGeneratedTestsToPassAndWriteMyOwnScenarioWithPropertyName)
            {
                new { systemUnderTestDeepCloneWithValueFunc }.AsTest().Must().NotBeNull(id);
                var systemUnderTestDeepCloneWith = systemUnderTestDeepCloneWithValueFunc();
                new { systemUnderTestDeepCloneWith }.AsTest().Must().NotBeNull(id);

                systemUnderTest = systemUnderTestDeepCloneWith.SystemUnderTest;
                new { systemUnderTest }.AsTest().Must().NotBeNull(id);

                var deepCloneWithMethodName = "DeepCloneWith" + withPropertyName;

                deepCloneWithMethod = typeof(T).GetMethodFiltered(deepCloneWithMethodName, MemberRelationships.DeclaredOrInherited, MemberOwners.Instance, MemberAccessModifiers.Public, throwIfNotFound: false);

                new { deepCloneWithMethod }.AsTest().Must().NotBeNull(id);

                // ReSharper disable once PossibleNullReferenceException
                var deepCloneWithMethodParameters = deepCloneWithMethod.GetParameters();
                new { deepCloneWithMethodParameters }.AsTest().Must().HaveCount(1, id);

                withValue = systemUnderTestDeepCloneWith.DeepCloneWithValue;

                var deepCloneWithMethodParameterType = deepCloneWithMethodParameters.Single().ParameterType;

                if (withValue == null)
                {
                    var deepCloneWithMethodParameterTypeIsValueType = deepCloneWithMethodParameterType.IsTypeAssignableToNull();

                    new { deepCloneWithMethodParameterTypeIsValueType }.AsTest().Must().BeTrue(id);
                }
                else
                {
                    var withValueTypeIsAssignableToDeepCloneWithMethodParameterType = withValue.GetType().IsAssignableTo(deepCloneWithMethodParameterType);

                    new { withValueTypeIsAssignableToDeepCloneWithMethodParameterType }.AsTest().Must().BeTrue(id);
                }

                var withProperty = typeof(T).GetPropertyFiltered(withPropertyName, MemberRelationships.DeclaredOrInherited, MemberOwners.Instance, MemberAccessModifiers.Public, throwIfNotFound: false);

                new { withProperty }.Must().NotBeNull(id);
            }

            this.Id = id;
            this.WithPropertyName = withPropertyName;
            this.SystemUnderTest = systemUnderTest;
            this.WithValue = withValue;
            this.DeepCloneWithMethod = deepCloneWithMethod;
        }

        /// <summary>
        /// Gets the identifier of the scenario.
        /// </summary>
        public string Id { get; }

        /// <summary>
        /// Gets the name of the property whose value is provided in the DeepCloneWith call.
        /// All other properties will be deep cloned EXCEPT this one.
        /// </summary>
        public string WithPropertyName { get; }

        /// <summary>
        /// Gets the object being tested.
        /// </summary>
        public T SystemUnderTest { get; }

        /// <summary>
        /// Gets the value to use when calling DeepCloneWith; <see cref="WithPropertyName"/> will
        /// be set to this value.
        /// </summary>
        public object WithValue { get; }

        /// <summary>
        /// Gets the DeepCloneWith method.
        /// </summary>
        public MethodInfo DeepCloneWithMethod { get; }

        /// <inheritdoc />
        public override string ToString()
        {
            var result = this.Id;

            return result;
        }
    }
}
