// --------------------------------------------------------------------------------------------------------------------
// <copyright file="RoundtripSerializationExtensions.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Serialization.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Serialization.Recipes
{
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Linq;

    using OBeautifulCode.Assertion.Recipes;
    using OBeautifulCode.Reflection.Recipes;
    using OBeautifulCode.Representation.System;
    using OBeautifulCode.Serialization.Bson;
    using OBeautifulCode.Serialization.Json;
    using OBeautifulCode.Serialization.PropertyBag;
    using OBeautifulCode.Type.Recipes;

    using static System.FormattableString;

    /// <summary>
    /// Verifies that the object to serialize is equal to the resulting deserialized object.
    /// </summary>
    /// <typeparam name="T">The type being tested.</typeparam>
    /// <param name="describedSerialization">The described serialization.</param>
    /// <param name="deserializedObject">The deserialized object.</param>
#if !OBeautifulCodeSerializationSolution
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Serialization.Recipes", "See package version number")]
    internal
#else
    public
#endif
    delegate void RoundtripSerializationVerification<in T>(
        DescribedSerializationBase describedSerialization,
        T deserializedObject);

    /// <summary>
    /// Extension methods for roundtrip serialization testing.
    /// </summary>
#if !OBeautifulCodeSerializationSolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Serialization.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static partial class RoundtripSerializationExtensions
    {
        private const AppDomainScenarios DefaultAppDomainScenarios = AppDomainScenarios.RoundtripInNewAppDomain | AppDomainScenarios.SerializeInNewAppDomainAndDeserializeInNewAppDomain;

        /// <summary>
        /// Test roundtrip serialization, asserting that the expected/provided value is equal to the deserialized value using
        /// <see cref="Verifications.BeEqualTo{T}(AssertionTracker, T, string, ApplyBecause, System.Collections.IDictionary)"/>.
        /// Use the following the serialization configuration wrappers for the type being tested:
        /// <see cref="TypesToRegisterBsonSerializationConfiguration{T}"/>
        /// <see cref="TypesToRegisterJsonSerializationConfiguration{T}"/>
        /// <see cref="TypesToRegisterPropertyBagSerializationConfiguration{T}"/>.
        /// </summary>
        /// <typeparam name="T">The type being tested.</typeparam>
        /// <param name="expected">The value to serialize, which should be equal to the resulting deserialized object.</param>
        /// <param name="testBson">Optional value indicating whether to test serialization to/from BSON.  DEFAULT is true.</param>
        /// <param name="testJson">Optional value indicating whether to test serialization to/from JSON.  DEFAULT is true.</param>
        /// <param name="testPropertyBag">Optional value indicating whether to test serialization to/from a Property Bag.  DEFAULT is false.</param>
        /// <param name="formats">The serialization formats to test.</param>
        /// <param name="appDomainScenarios">Optional value that specifies various scenarios of serializing and de-serializing in the current App Domain or a new App Domain.  DEFAULT is test the roundtrip in a new App Domain and also to serialize in a new App Domain and de-serialize in a new, but different App Domain.</param>
        public static void RoundtripSerializeUsingTypesToRegisterConfigWithBeEqualToAssertion<T>(
            this T expected,
            bool testBson = true,
            bool testJson = true,
            bool testPropertyBag = false,
            IReadOnlyCollection<SerializationFormat> formats = null,
            AppDomainScenarios appDomainScenarios = DefaultAppDomainScenarios)
        {
            expected.RoundtripSerializeWithBeEqualToAssertion(
                typeof(TypesToRegisterBsonSerializationConfiguration<T>),
                typeof(TypesToRegisterJsonSerializationConfiguration<T>),
                typeof(TypesToRegisterPropertyBagSerializationConfiguration<T>),
                testBson,
                testJson,
                testPropertyBag,
                formats,
                appDomainScenarios);
        }

        /// <summary>
        /// Test roundtrip serialization, asserting that the expected/provided value is equal to the deserialized value using
        /// <see cref="Verifications.BeEqualTo{T}(AssertionTracker, T, string, ApplyBecause, System.Collections.IDictionary)"/>,
        /// with the serialization configuration type(s) specified.
        /// </summary>
        /// <typeparam name="T">The type being tested.</typeparam>
        /// <param name="expected">The value to serialize, which should be equal to the resulting deserialized object.</param>
        /// <param name="bsonSerializationConfigurationType">Optional type of the serialization configuration to use for BSON testing.  DEFAULT is null; <see cref="NullBsonSerializationConfiguration"/> will be used.</param>
        /// <param name="jsonSerializationConfigurationType">Optional type of the serialization configuration to use for JSON testing.  DEFAULT is null; <see cref="NullJsonSerializationConfiguration"/> will be used.</param>
        /// <param name="propertyBagSerializationConfigurationType">Optional type of the serialization configuration to use for Property Bag testing.  DEFAULT is null; <see cref="NullPropertyBagSerializationConfiguration"/> will be used.</param>
        /// <param name="testBson">Optional value indicating whether to test serialization to/from BSON.  DEFAULT is true.</param>
        /// <param name="testJson">Optional value indicating whether to test serialization to/from JSON.  DEFAULT is true.</param>
        /// <param name="testPropertyBag">Optional value indicating whether to test serialization to/from a Property Bag.  DEFAULT is false.</param>
        /// <param name="formats">The serialization formats to test.</param>
        /// <param name="appDomainScenarios">Optional value that specifies various scenarios of serializing and de-serializing in the current App Domain or a new App Domain.  DEFAULT is test the roundtrip in a new App Domain and also to serialize in a new App Domain and de-serialize in a new, but different App Domain.</param>
        public static void RoundtripSerializeWithBeEqualToAssertion<T>(
            this T expected,
            Type bsonSerializationConfigurationType = null,
            Type jsonSerializationConfigurationType = null,
            Type propertyBagSerializationConfigurationType = null,
            bool testBson = true,
            bool testJson = true,
            bool testPropertyBag = false,
            IReadOnlyCollection<SerializationFormat> formats = null,
            AppDomainScenarios appDomainScenarios = DefaultAppDomainScenarios)
        {
            RoundtripSerializeWithCallbackVerification(
                expected,
                (yieldedDescribedSerialization, deserializedObject) => deserializedObject.AsTest().Must().BeEqualTo(expected),
                bsonSerializationConfigurationType,
                jsonSerializationConfigurationType,
                propertyBagSerializationConfigurationType,
                testBson,
                testJson,
                testPropertyBag,
                formats,
                appDomainScenarios);
        }

        /// <summary>
        /// Test roundtrip serialization, asserting that the expected/provided value is equal to the deserialized value using
        /// the specified callback, with the serialization configuration type(s) specified.
        /// </summary>
        /// <typeparam name="T">The type being tested.</typeparam>
        /// <param name="expected">The value to serialize, which should be equal to the resulting deserialized object.</param>
        /// <param name="verificationCallback">Callback to verify that the expected/provided value is equal to the deserialized value.</param>
        /// <param name="bsonSerializationConfigurationType">Optional type of the serialization configuration to use for BSON testing.  DEFAULT is null; <see cref="NullBsonSerializationConfiguration"/> will be used.</param>
        /// <param name="jsonSerializationConfigurationType">Optional type of the serialization configuration to use for JSON testing.  DEFAULT is null; <see cref="NullJsonSerializationConfiguration"/> will be used.</param>
        /// <param name="propertyBagSerializationConfigurationType">Optional type of the serialization configuration to use for Property Bag testing.  DEFAULT is null; <see cref="NullPropertyBagSerializationConfiguration"/> will be used.</param>
        /// <param name="testBson">Optional value indicating whether to test serialization to/from BSON.  DEFAULT is true.</param>
        /// <param name="testJson">Optional value indicating whether to test serialization to/from JSON.  DEFAULT is true.</param>
        /// <param name="testPropertyBag">Optional value indicating whether to test serialization to/from a Property Bag.  DEFAULT is false.</param>
        /// <param name="formats">The serialization formats to test.</param>
        /// <param name="appDomainScenarios">Optional value that specifies various scenarios of serializing and de-serializing in the current App Domain or a new App Domain.  DEFAULT is test the roundtrip in a new App Domain and also to serialize in a new App Domain and de-serialize in a new, but different App Domain.</param>
        public static void RoundtripSerializeWithCallbackVerification<T>(
            this T expected,
            RoundtripSerializationVerification<T> verificationCallback,
            Type bsonSerializationConfigurationType = null,
            Type jsonSerializationConfigurationType = null,
            Type propertyBagSerializationConfigurationType = null,
            bool testBson = true,
            bool testJson = true,
            bool testPropertyBag = false,
            IReadOnlyCollection<SerializationFormat> formats = null,
            AppDomainScenarios appDomainScenarios = DefaultAppDomainScenarios)
        {
            new { appDomainScenarios }.AsArg().Must().NotBeEqualTo(AppDomainScenarios.None);

            formats = formats ?? new[] { SerializationFormat.String, SerializationFormat.Binary };

            formats.AsArg().Must().NotBeNullNorEmptyEnumerable();

            var serializerRepresentations = new List<SerializerRepresentation>();

            if (testBson)
            {
                var serializerDescription = new SerializerRepresentation(SerializationKind.Bson, bsonSerializationConfigurationType?.ToRepresentation());

                serializerRepresentations.Add(serializerDescription);
            }

            if (testJson)
            {
                var serializerRepresentation = new SerializerRepresentation(SerializationKind.Json, jsonSerializationConfigurationType?.ToRepresentation());

                serializerRepresentations.Add(serializerRepresentation);
            }

            if (testPropertyBag)
            {
                var serializerDescription = new SerializerRepresentation(SerializationKind.PropertyBag, propertyBagSerializationConfigurationType?.ToRepresentation());

                serializerRepresentations.Add(serializerDescription);
            }

            if (!serializerRepresentations.Any())
            {
                throw new InvalidOperationException("No serializers are being tested.");
            }

            Func<SerializerRepresentation, SerializationFormat, object, DescribedSerializationBase> serializeFunc = Serialize;

            Func<DescribedSerializationBase, T> deserializeFunc = Deserialize<T>;

            Func<SerializerRepresentation, SerializationFormat, T, Tuple<DescribedSerializationBase, T>> serializeAndDeserializeFunc = SerializeAndDeserialize<T>;

            foreach (var serializerRepresentation in serializerRepresentations)
            {
                foreach (var format in formats)
                {
                    if (appDomainScenarios.HasFlag(AppDomainScenarios.RoundtripInCurrentAppDomain))
                    {
                        var serializeAndDeserializeResult = serializeAndDeserializeFunc(serializerRepresentation, format, expected);

                        RunVerification(serializeAndDeserializeResult.Item1, verificationCallback, AppDomainScenarios.RoundtripInCurrentAppDomain, serializeAndDeserializeResult.Item2);
                    }

                    if (appDomainScenarios.HasFlag(AppDomainScenarios.RoundtripInNewAppDomain))
                    {
                        var serializeAndDeserializeResult = serializeAndDeserializeFunc.ExecuteInNewAppDomain(serializerRepresentation, format, expected);

                        RunVerification(serializeAndDeserializeResult.Item1, verificationCallback, AppDomainScenarios.RoundtripInNewAppDomain, serializeAndDeserializeResult.Item2);
                    }

                    if (appDomainScenarios.HasFlag(AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain))
                    {
                        var describedSerialization = serializeFunc(serializerRepresentation, format, expected);

                        var deserializedObject = deserializeFunc.ExecuteInNewAppDomain(describedSerialization);

                        RunVerification(describedSerialization, verificationCallback, AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain, deserializedObject);
                    }

                    if (appDomainScenarios.HasFlag(AppDomainScenarios.SerializeInNewAppDomainAndDeserializeInNewAppDomain))
                    {
                        var describedSerialization = serializeFunc.ExecuteInNewAppDomain(serializerRepresentation, format, expected);

                        var deserializedObject = deserializeFunc.ExecuteInNewAppDomain(describedSerialization);

                        RunVerification(describedSerialization, verificationCallback, AppDomainScenarios.SerializeInNewAppDomainAndDeserializeInNewAppDomain, deserializedObject);
                    }
                }
            }
        }

        private static void RunVerification<T>(
            DescribedSerializationBase describedSerialization,
            RoundtripSerializationVerification<T> verificationCallback,
            AppDomainScenarios appDomainScenario,
            T deserializedObject)
        {
            new { verificationCallback }.AsArg().Must().NotBeNull();

            try
            {
                verificationCallback(describedSerialization, deserializedObject);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(Invariant($"Failed to roundtrip specified object to/from {describedSerialization.SerializerRepresentation.SerializationKind} {describedSerialization.GetSerializationFormat()} using {describedSerialization.SerializerRepresentation.SerializationConfigType.ResolveFromLoadedTypes().ToStringReadable()} with the App Domain Scenario '{appDomainScenario}'.  Serialized payload is: {describedSerialization.GetSerializedPayloadAsEncodedString()}.  Deserialized object is: {deserializedObject}."), ex);
            }
        }

        private static DescribedSerializationBase Serialize(
            SerializerRepresentation serializerRepresentation,
            SerializationFormat serializationFormat,
            object objectToSerialize)
        {
            var result = objectToSerialize.ToDescribedSerialization(serializerRepresentation, serializationFormat);

            return result;
        }

        private static T Deserialize<T>(
            DescribedSerializationBase describedSerialization)
        {
            var result = describedSerialization.DeserializePayload<T>();

            return result;
        }

        private static Tuple<DescribedSerializationBase, T> SerializeAndDeserialize<T>(
            SerializerRepresentation serializerRepresentation,
            SerializationFormat serializationFormat,
            T objectToSerialize)
        {
            var serializer = SerializerFactory.Instance.BuildSerializer(serializerRepresentation);

            var describedSerialization = objectToSerialize.ToDescribedSerializationUsingSpecificSerializer(serializer, serializationFormat);

            var deserializedObject = (T)describedSerialization.DeserializePayloadUsingSpecificSerializer(serializer);

            // note that we cannot return a ValueTuple (DescribedSerializationBase describedSerialization, T actual)
            // here because ValueTuple is not [Serializable]
            var result = new Tuple<DescribedSerializationBase, T>(describedSerialization, deserializedObject);

            return result;
        }
    }
}
