// --------------------------------------------------------------------------------------------------------------------
// <copyright file="NaosDeploymentBootstrapper.cs" company="Naos Project">
//    Copyright (c) Naos Project 2019. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Naos.Deployment.Bootstrapper source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Naos.Deployment.Console
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Management.Automation;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Threading.Tasks;
    using System.Xml.Serialization;

    using Naos.AWS.Core;
    using Naos.AWS.Domain;
    using Naos.CodeAnalysis.Recipes;
    using Naos.Configuration.Domain;
    using Naos.Deployment.ComputingManagement;
    using Naos.Deployment.Core;
    using Naos.Deployment.Core.CertificateManagement;
    using Naos.Deployment.Domain;
    using Naos.Deployment.Tracking;
    using Naos.Diagnostics.Domain;
    using Naos.Logging.Domain;
    using Naos.MachineManagement.Domain;
    using Naos.MachineManagement.Factory;
    using Naos.Packaging.Domain;
    using Naos.Packaging.NuGet;
    using Naos.Recipes.RunWithRetry;

    using OBeautifulCode.Assertion.Recipes;
    using OBeautifulCode.Execution.Recipes;
    using OBeautifulCode.Representation.System;
    using OBeautifulCode.Security.Recipes;
    using OBeautifulCode.Serialization;
    using OBeautifulCode.Serialization.Json;

    using Spritely.Redo;

    using static System.FormattableString;
    using InstanceStatus = Naos.Deployment.Domain.InstanceStatus;

    /// <summary>
    /// Bootstrapper for deployment logic to bridge commands from command line and various components to create an end to end solution.
    /// </summary>
#if !NaosDeploymentConsole
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Naos.Deployment.Bootstrapper", "See package version number")]
#endif
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Bridging logic expected to have a lot of type coupling.")]
    public static class NaosDeploymentBootstrapper
    {
        private static readonly object NugetAnnouncementFileLock = new object();
        private static readonly ISerializeAndDeserialize ConfigFileSerializer = new ObcJsonSerializer<NaosDeploymentCoreJsonSerializationConfiguration>();

        private static void NugetAnnouncementAction(string output, string nugetAnnouncementFilePath)
        {
            if (!string.IsNullOrWhiteSpace(nugetAnnouncementFilePath))
            {
                lock (NugetAnnouncementFileLock)
                {
                    File.AppendAllText(nugetAnnouncementFilePath, output);
                }
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "This might still get used and is a weird situation.")]
        private static void CopyAll(DirectoryInfo source, DirectoryInfo target)
        {
            // https://stackoverflow.com/questions/58744/copy-the-entire-contents-of-a-directory-in-c-sharp (MSDN solution)
            Directory.CreateDirectory(target.FullName);

            // Copy each file into the new directory.
            foreach (var fi in source.GetFiles())
            {
                fi.CopyTo(Path.Combine(target.FullName, fi.Name), true);
            }

            // Copy each subdirectory using recursion.
            foreach (var sourceSubDir in source.GetDirectories())
            {
                var nextTargetSubDir = target.CreateSubdirectory(sourceSubDir.Name);
                CopyAll(sourceSubDir, nextTargetSubDir);
            }
        }

        /// <summary>
        /// Gets the Arcology drive report.
        /// </summary>
        /// <param name="environment">The environment.</param>
        /// <param name="environmentType">Type of the environment.</param>
        /// <param name="credentialsJson">The credentials json.</param>
        /// <param name="infrastructureTrackerJson">The infrastructure tracker json.</param>
        /// <param name="threshold">The threshold.</param>
        /// <returns>Map of instance name to <see cref="CheckDrivesReport" />.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "This is a good practice in the deployment console which sits at the top of the dependency tree.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = NaosSuppressBecause.CA1502_AvoidExcessiveComplexity_DisagreeWithAssessment)]
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = NaosSuppressBecause.CA1506_AvoidExcessiveClassCoupling_DisagreeWithAssessment)]
        internal static IReadOnlyDictionary<string, CheckDrivesReport> GetArcologyDriveReport(
            string environment,
            EnvironmentType environmentType,
            string credentialsJson,
            string infrastructureTrackerJson,
            decimal threshold)
        {
            var result = new Dictionary<string, CheckDrivesReport>();
            var utcNow = DateTime.UtcNow;
            var getDriveInfoScript = @"{ $output = Get-PSDrive | ?{$_.Provider.Name -eq 'FileSystem'} | %{""$($_.Name):\,$($_.Free),$($_.Used+$_.Free)""}; return $output; }";
            void GetDriveReports(
                ITrackComputingInfrastructure tracker,
                IManageComputingInfrastructure manager)
            {
                Func<Task<IReadOnlyCollection<InstanceDescription>>> getInstances = () => tracker.GetAllInstanceDescriptionsAsync(environment);
                var instances = getInstances.ExecuteSynchronously();
                foreach (var instance in instances)
                {
                    try
                    {
                        var address = instance.PrivateIpAddress;
                        var user = "administrator";
                        Func<Task<string>> privateKeyOfInstanceByIdAsyncFunc =
                            () => tracker.GetPrivateKeyOfInstanceByIdAsync(environment, instance.Id);
                        var privateKey = privateKeyOfInstanceByIdAsyncFunc.ExecuteSynchronously();
                        privateKey.AsArg(Invariant($"FailedToFindPrivateKeyByInstanceId-{instance.Id}")).Must().NotBeNull();
                        Func<Task<string>> administratorPasswordForInstanceAsyncFunc =
                            () => manager.GetAdministratorPasswordForInstanceAsync(instance, privateKey);
                        var password = administratorPasswordForInstanceAsyncFunc.ExecuteSynchronously();
                        password.AsArg(Invariant($"FailedToGetPasswordFor-{instance.Id}")).Must().NotBeNullNorWhiteSpace();
                        ICollection<dynamic> outputRaw;
                        using (var machineManager = new MachineManagement.WinRm.WinRmMachineManager(address, user, password, true))
                        {
                            outputRaw = machineManager.RunScript(getDriveInfoScript);
                        }

                        var output = outputRaw?.FirstOrDefault()?.ToString();
                        if (string.IsNullOrWhiteSpace(output))
                        {
                            throw new ArgumentException(Invariant($"FailedToGetDriveInfoFor-{instance.Id}"));
                        }

                        var singleDriveReports = new Dictionary<string, CheckSingleDriveReport>();

                        foreach (var driveLine in output.Split(
                            new[]
                            {
                                Environment.NewLine,
                            },
                            StringSplitOptions.RemoveEmptyEntries))
                        {
                            var driveLineSplit = driveLine.Split(',');
                            var driveName = driveLineSplit[0];
                            var totalFreeSpaceInBytesString = driveLineSplit[1];
                            var totalFreeSpaceInBytes = long.Parse(totalFreeSpaceInBytesString, CultureInfo.InvariantCulture);
                            var totalSizeInBytesString = driveLineSplit[2];
                            var totalSizeInBytes = long.Parse(totalSizeInBytesString, CultureInfo.InvariantCulture);
                            var freeSpaceToTotalRatio = ((decimal)totalFreeSpaceInBytes / (decimal)totalSizeInBytes);
                            var status = freeSpaceToTotalRatio < threshold ? CheckStatus.Failure : CheckStatus.Success;
                            var singleDriveReport = new CheckSingleDriveReport(driveName, status, totalFreeSpaceInBytes, totalSizeInBytes);
                            singleDriveReports.Add(driveName, singleDriveReport);
                        }

                        var reportStatus = singleDriveReports.Select(_ => _.Value.Status).ToList().ReduceToSingleStatus();
                        var driveReport = new CheckDrivesReport(reportStatus, singleDriveReports, new CheckDrivesOp(threshold), utcNow);
                        result.Add(instance.Name, driveReport);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e);
                        result.Add(instance.Name, null);
                    }
                }
            }

            BootRunComputingManagerOperation(environmentType, GetDriveReports, credentialsJson, infrastructureTrackerJson);

            return result;
        }

        /// <summary>
        /// Gets new credentials on the computing platform provider, will be prepped such that output can be saved to a variable and passed back in for CredentialsJson parameter.
        /// </summary>
        /// <param name="location">Computing platform provider location to make the call against.</param>
        /// <param name="tokenLifespan">Life span of the credentials (in format dd:hh:mm).</param>
        /// <param name="username">Username of the credentials.</param>
        /// <param name="password">Password of the credentials.</param>
        /// <param name="virtualMfaDeviceId">Virtual MFA device id of the credentials.</param>
        /// <param name="mfaValue">Token from the MFA device to use when authenticating.</param>
        /// <param name="escapeQuotes">Optional value indicating whether or not to escape quotes; DEFAULT is true.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        internal static void GetNewCredentialsJson(
            string location,
            TimeSpan tokenLifespan,
            string username,
            string password,
            string virtualMfaDeviceId,
            string mfaValue,
            bool escapeQuotes,
            Action<string> localResultAnnouncer)
        {
            var retObj = ComputingInfrastructureManagerForAws.GetNewCredentials(
                location,
                tokenLifespan,
                username,
                password,
                virtualMfaDeviceId,
                mfaValue);

            var configFileManager = new ConfigFileManager(
                new[] { Config.CommonPrecedence },
                Config.DefaultConfigDirectoryName,
                ConfigFileSerializer);

            var rawRet = configFileManager.SerializeConfigToFileText(retObj);

            // prep to be returned in a way that can be piped to a variable and then passed back in...
            var withoutNewLines = rawRet.Replace(Environment.NewLine, string.Empty);
            var escapedQuotes = escapeQuotes ? withoutNewLines.Replace("\"", "\\\"") : withoutNewLines;

            var ret = escapedQuotes;
            localResultAnnouncer(ret);
        }

        /// <summary>
        /// Gets the password of an instance from the provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="environment">Environment name where instance to get password is located.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        internal static void GetPassword(
            string credentialsJson,
            string infrastructureTrackerJson,
            string instanceName,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            void GetPassword(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => manager.GetInstanceDescriptionAsync(environment, instanceName);
                var instance = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                instance.AsArg(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                Func<Task<string>> privateKeyOfInstanceByIdAsyncFunc = () => tracker.GetPrivateKeyOfInstanceByIdAsync(environment, instance.Id);
                var privateKey = privateKeyOfInstanceByIdAsyncFunc.ExecuteSynchronously();
                privateKey.AsArg(Invariant($"FailedToFindPrivateKeyByInstanceId-{instance.Id}")).Must().NotBeNull();

                Func<Task<string>> administratorPasswordForInstanceAsyncFunc = () => manager.GetAdministratorPasswordForInstanceAsync(instance, privateKey);
                var password = administratorPasswordForInstanceAsyncFunc.ExecuteSynchronously();
                password.AsArg(Invariant($"FailedToGetPasswordFor-{instance.Id}")).Must().NotBeNullNorWhiteSpace();

                localResultAnnouncer(password);
            }

            BootRunComputingManagerOperation(environmentType, GetPassword, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the private key of the computing container with the specified accessibility.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="accessibility">Accessibility of the computing container to get the private key for.</param>
        /// <param name="environment">Environment name where instance to get password is located.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        internal static void GetComputingContainerPrivateKey(
            string credentialsJson,
            string infrastructureTrackerJson,
            InstanceAccessibility accessibility,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            void GetKey(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<string>> privateKeyOfComputingContainerAsyncFunc =
                    () => tracker.GetPrivateKeyOfComputingContainerAsync(environment, accessibility);
                var privateKey = privateKeyOfComputingContainerAsyncFunc.ExecuteSynchronously();

                localResultAnnouncer(privateKey);
            }

            BootRunComputingManagerOperation(environmentType, GetKey, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the status of the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        public static void GetInstanceStatus(
            string credentialsJson,
            string infrastructureTrackerJson,
            string instanceName,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            void GetInstanceStatus(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => manager.GetInstanceDescriptionAsync(environment, instanceName);
                var instance = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                instance.AsArg(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                Func<Task<InstanceStatus>> instanceStatusAsyncFunc = () => manager.GetInstanceStatusAsync(instance.Id, instance.Location);
                var status = instanceStatusAsyncFunc.ExecuteSynchronously();
                status.AsArg(Invariant($"FailedToGetStatusFor-{instance.Id}")).Must().NotBeNull();

                localResultAnnouncer(status.ToString());
            }

            BootRunComputingManagerOperation(environmentType, GetInstanceStatus, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the status of the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        public static void GetConsoleOutput(
            string credentialsJson,
            string infrastructureTrackerJson,
            string instanceName,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            void GetConsoleOutput(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => manager.GetInstanceDescriptionAsync(environment, instanceName);
                var instance = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                instance.AsArg(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                Func<Task<string>> consoleOutputFromInstanceAsyncFunc = () => manager.GetConsoleOutputFromInstanceAsync(instance);
                var encodedOutput = consoleOutputFromInstanceAsyncFunc.ExecuteSynchronously();
                encodedOutput.AsArg(Invariant($"FailedToGetConsoleOutputFor-{instance.Id}")).Must().NotBeNull();

                var bytes = Convert.FromBase64String(encodedOutput);
                var output = Encoding.UTF8.GetString(bytes);

                localResultAnnouncer(output);
            }

            BootRunComputingManagerOperation(environmentType, GetConsoleOutput, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the instances that are active (not terminated) from the underlying computing provider.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        public static void GetActiveInstancesFromProvider(
            string credentialsJson,
            string infrastructureTrackerJson,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            void GetInstancesFromProvider(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<IList<InstanceDetailsFromComputingPlatform>>> activeInstancesFromProviderAsyncFunc =
                    () => manager.GetActiveInstancesFromProviderAsync(environment);
                var instances = activeInstancesFromProviderAsyncFunc.ExecuteSynchronously();

                instances.ToList().OrderBy(_ => _.Name).ToList().ForEach(_ =>
                    localResultAnnouncer(Invariant($"{_.Id}\t{_.PrivateIpAddress}\t{_.Name}")));
            }

            BootRunComputingManagerOperation(environmentType, GetInstancesFromProvider, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the instance names (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a') in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        public static void GetInstanceNames(
            string credentialsJson,
            string infrastructureTrackerJson,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            void GetInstances(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<IReadOnlyCollection<InstanceDescription>>> allInstanceDescriptionsAsyncFunc =
                    () => tracker.GetAllInstanceDescriptionsAsync(environment);
                var instances = allInstanceDescriptionsAsyncFunc.ExecuteSynchronously();

                instances.ToList().ForEach(_ => localResultAnnouncer(Invariant($"{_.ComputerName}\t{_.PrivateIpAddress}")));
            }

            BootRunComputingManagerOperation(environmentType, GetInstances, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the instances only in either tracking or computer platform.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="environment">Environment name to check.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        public static void GetInstancesInTrackingAndNotProviderOrReverse(
            string credentialsJson,
            string infrastructureTrackerJson,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            void GetInstanceDifferences(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<IReadOnlyCollection<InstanceDescription>>> allInstanceDescriptionsAsyncFunc =
                    () => tracker.GetAllInstanceDescriptionsAsync(environment);
                var instancesInTracker = allInstanceDescriptionsAsyncFunc.ExecuteSynchronously();
                Func<Task<IList<InstanceDetailsFromComputingPlatform>>> activeInstancesFromProviderAsyncFunc =
                    () => manager.GetActiveInstancesFromProviderAsync(environment);
                var instancesInProvider = activeInstancesFromProviderAsyncFunc.ExecuteSynchronously();

                var instancesOnlyInTracker = instancesInTracker
                                            .Where(
                                                 tracked =>
                                                     !instancesInProvider.Any(provider => provider.PrivateIpAddress == tracked.PrivateIpAddress))
                                            .ToList();

                var instancesOnlyInProvider = instancesInProvider
                                             .Where(
                                                  provider =>
                                                      !instancesInTracker.Any(tracked => tracked.PrivateIpAddress == provider.PrivateIpAddress))
                                             .ToList();

                instancesOnlyInTracker.ForEach(_ =>
                    localResultAnnouncer(Invariant($"only-tracked\t{_.Id}\t{_.PrivateIpAddress}\t{_.Name}")));
                instancesOnlyInProvider.ForEach(_ =>
                    localResultAnnouncer(Invariant($"un-tracked\t{_.Id}\t{_.PrivateIpAddress}\t{_.Name}")));
            }

            BootRunComputingManagerOperation(environmentType, GetInstanceDifferences, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Removes an instance from tracking that is not in the computing platform.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of instance to remove.</param>
        /// <param name="environment">Environment name where instance should be removed.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        public static void RemoveTrackedInstance(
            string credentialsJson,
            string infrastructureTrackerJson,
            string instanceName,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            void RemoveTrackedInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                localResultAnnouncer(Invariant($"Removing {instanceName}."));

                Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => manager.GetInstanceDescriptionAsync(environment, instanceName); var instance = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                localResultAnnouncer(Invariant($"Found {instanceName} - {instance.PrivateIpAddress} - {instance.Name}."));

                Func<Task> terminateInstanceAsyncFunc = () => manager.TerminateInstanceAsync(environment, instance.Id, instance.Location, true);
                terminateInstanceAsyncFunc.ExecuteSynchronously();

                localResultAnnouncer(Invariant($"Removed {instanceName}."));
            }

            BootRunComputingManagerOperation(environmentType, RemoveTrackedInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Removes an instance from tracking that is not in the computing platform.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="privateIpAddressOfInstanceToRemove">IP Address of instance to remove (cannot be used with <paramref name="instanceNameOfInstanceToRemove" />).</param>
        /// <param name="instanceNameOfInstanceToRemove">Name of instance to remove (cannot be used with <paramref name="privateIpAddressOfInstanceToRemove" />).</param>
        /// <param name="environment">Environment name with un-deployed instance.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Ip", Justification = "Spelling/name is correct.")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Ip", Justification = "Spelling/name is correct.")]
        public static void RemoveTrackedInstanceNotInComputingPlatform(
            string credentialsJson,
            string infrastructureTrackerJson,
            string privateIpAddressOfInstanceToRemove,
            string instanceNameOfInstanceToRemove,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            if (string.IsNullOrWhiteSpace(privateIpAddressOfInstanceToRemove) && string.IsNullOrWhiteSpace(instanceNameOfInstanceToRemove))
            {
                throw new ArgumentException(Invariant($"Must specify EITHER {nameof(privateIpAddressOfInstanceToRemove)} OR {nameof(instanceNameOfInstanceToRemove)}"));
            }

            if (!string.IsNullOrWhiteSpace(privateIpAddressOfInstanceToRemove) && !string.IsNullOrWhiteSpace(instanceNameOfInstanceToRemove))
            {
                throw new ArgumentException(Invariant($"Cannot specify BOTH {nameof(privateIpAddressOfInstanceToRemove)} OR {nameof(instanceNameOfInstanceToRemove)}"));
            }

            void RemoveTrackedInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                if (!string.IsNullOrWhiteSpace(instanceNameOfInstanceToRemove))
                {
                    Func<Task<IReadOnlyCollection<InstanceDescription>>> allInstanceDescriptionsAsyncFunc =
                        () => tracker.GetAllInstanceDescriptionsAsync(environment);
                    var instancesInTracking = allInstanceDescriptionsAsyncFunc.ExecuteSynchronously();
                    var trackedInstance = instancesInTracking.SingleOrDefault(
                        _ => (_.ComputerName ?? string.Empty).Equals(instanceNameOfInstanceToRemove, StringComparison.CurrentCultureIgnoreCase));
                    if (trackedInstance != null)
                    {
                        privateIpAddressOfInstanceToRemove = trackedInstance.PrivateIpAddress;
                    }
                }

                Func<Task<IList<InstanceDetailsFromComputingPlatform>>> activeInstancesFromProviderAsyncFunc =
                    () => manager.GetActiveInstancesFromProviderAsync(environment);
                var instancesInProvider = activeInstancesFromProviderAsyncFunc.ExecuteSynchronously();
                var instanceInCloud = instancesInProvider.SingleOrDefault(
                    _ => (_.PrivateIpAddress ?? string.Empty).Equals(privateIpAddressOfInstanceToRemove, StringComparison.CurrentCultureIgnoreCase));

                if (instanceInCloud != null)
                {
                    throw new ArgumentException(Invariant(
                        $"IP Address provided: {privateIpAddressOfInstanceToRemove} exists in Provider; ID: {instanceInCloud.Id}, Name: {instanceInCloud.Name}"));
                }

                Func<Task> removeInstanceFromTrackingFunc = () => tracker.RemoveInstanceFromTracking(environment, privateIpAddressOfInstanceToRemove);
                removeInstanceFromTrackingFunc.ExecuteSynchronously();
                localResultAnnouncer(Invariant($"Removed {privateIpAddressOfInstanceToRemove} from Tracking."));
            }

            BootRunComputingManagerOperation(environmentType, RemoveTrackedInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Removes an instance from the computing platform that is not in tracking.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="systemIdOfInstanceToRemove">ID of instance to remove (ID from the computing platform).</param>
        /// <param name="environment">Environment name with un-tracked instance.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        public static void RemoveInstanceInComputingPlatformNotTracked(
            string credentialsJson,
            string infrastructureTrackerJson,
            string systemIdOfInstanceToRemove,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            void RemoveUntrackedInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<IList<InstanceDetailsFromComputingPlatform>>> activeInstancesFromProviderAsyncFunc =
                    () => manager.GetActiveInstancesFromProviderAsync(environment);
                var instancesInProvider = activeInstancesFromProviderAsyncFunc.ExecuteSynchronously();

                var instanceInCloud = instancesInProvider.SingleOrDefault(_ => (_.Id ?? string.Empty).Equals(systemIdOfInstanceToRemove, StringComparison.CurrentCultureIgnoreCase));

                if (instanceInCloud == null)
                {
                    throw new ArgumentException(
                        Invariant($"ID provided: {systemIdOfInstanceToRemove} does NOT exist in provider."));
                }

                Func<Task<IReadOnlyCollection<InstanceDescription>>> allInstanceDescriptionsAsyncFunc = () => tracker.GetAllInstanceDescriptionsAsync(environment);
                var instancesInTracking = allInstanceDescriptionsAsyncFunc.ExecuteSynchronously();
                var trackedInstance = instancesInTracking.SingleOrDefault(
                    _ => (_.Id ?? string.Empty).Equals(systemIdOfInstanceToRemove, StringComparison.OrdinalIgnoreCase));

                if (trackedInstance != null)
                {
                    throw new ArgumentException(Invariant(
                        $"ID provided: {systemIdOfInstanceToRemove} does exist in Tracking; ID: {trackedInstance.Id}, Name: {trackedInstance.Name}"));
                }

                Func<Task> terminateInstanceAsyncFunc = () => manager.TerminateInstanceAsync(
                                                            environment,
                                                            systemIdOfInstanceToRemove,
                                                            instanceInCloud.Location,
                                                            true);

                terminateInstanceAsyncFunc.ExecuteSynchronously();

                localResultAnnouncer(Invariant($"Removed {systemIdOfInstanceToRemove} from Provider."));
            }

            BootRunComputingManagerOperation(environmentType, RemoveUntrackedInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Gets the details of the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="environment">Environment name where instance exists.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="localResultAnnouncer">Call back action to use with result.</param>
        public static void GetInstanceDetails(
            string credentialsJson,
            string infrastructureTrackerJson,
            string instanceName,
            string environment,
            EnvironmentType environmentType,
            Action<string> localResultAnnouncer)
        {
            var configFileManager = new ConfigFileManager(
                new[] { Config.CommonPrecedence },
                Config.DefaultConfigDirectoryName,
                ConfigFileSerializer);

            void GetInstanceDetails(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => manager.GetInstanceDescriptionAsync(environment, instanceName);
                var instance = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                instance.AsArg(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                var instanceText = configFileManager.SerializeConfigToFileText(instance);

                localResultAnnouncer(instanceText);
            }

            BootRunComputingManagerOperation(environmentType, GetInstanceDetails, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Starts a remote session instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="environmentType">Environment type.</param>
        /// <param name="shouldConnectInFullScreen">A value indicating whether or not to connect in full screen mode.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Weird logic to get terminal services to automatically connect, complexity not a problem here.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Weird logic to get terminal services to automatically connect, coupling not a problem here.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope", Justification = "Object is disposed correctly.")]
        public static void ConnectToInstance(
            string credentialsJson,
            string infrastructureTrackerJson,
            string instanceName,
            string environment,
            EnvironmentType environmentType,
            bool shouldConnectInFullScreen)
        {
            void Connect(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                using (var activity = Log.With(() => new { Name = instanceName }))
                {
                    activity.Write(() => "Starting");
                    Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => manager.GetInstanceDescriptionAsync(environment, instanceName);
                    var instance = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                    instance.AsArg(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();
                    activity.Write(() => Invariant($"Found instance: {instance.Id}"));

                    Func<Task<string>> privateKeyOfInstanceByIdAsyncFunc = () => tracker.GetPrivateKeyOfInstanceByIdAsync(environment, instance.Id);
                    var privateKey = privateKeyOfInstanceByIdAsyncFunc.ExecuteSynchronously();
                    privateKey.AsArg(Invariant($"FailedToFindPrivateKeyByInstanceId-{instance.Id}")).Must().NotBeNull();
                    activity.Write(() => Invariant($"Found key for password decryption."));

                    var address = instance.PrivateIpAddress;
                    var dnsStrategies = instance.DeployedPackages.Values
                        .SelectMany(_ => _?.GetInitializationStrategiesOf<InitializationStrategyDnsEntry>())
                        .Where(_ => _ != null).ToList();
                    if (dnsStrategies.Any())
                    {
                        var allPrivateDnsEntries = dnsStrategies.Select(_ => _.PrivateDnsEntry).Distinct().ToList();
                        var tempAddress = allPrivateDnsEntries.First().Replace("{environment}", environment);

                        // can't deal with other tokens, use IP.
                        if (!tempAddress.Contains("{"))
                        {
                            address = tempAddress;
                        }
                    }

                    var user = "administrator";
                    Func<Task<string>> administratorPasswordForInstanceAsyncFunc = () => manager.GetAdministratorPasswordForInstanceAsync(instance, privateKey);
                    var password =
                        administratorPasswordForInstanceAsyncFunc.ExecuteSynchronously();
                    password.AsArg(Invariant($"FailedToGetPasswordFor-{instance.Id}")).Must().NotBeNullNorWhiteSpace();
                    activity.Write(() => Invariant($"Found password."));

                    // Help from: https://stackoverflow.com/questions/11296819/run-mstsc-exe-with-specified-username-and-password
                    using (var cmdKeyInitProcess = new Process
                    {
                        StartInfo = new ProcessStartInfo(
                            Environment.ExpandEnvironmentVariables(@"%SystemRoot%\system32\cmdkey.exe"),
                            Invariant($"/generic:TERMSRV/{address} /user:\"{user}\" /pass:\"{password}\""))
                        {
                            RedirectStandardOutput = true, // want to redirect output b/c we do not want to show it on the main application UNLESS there is an issue.
                            RedirectStandardError = true, // want to redirect output b/c we do not want to show it on the main application UNLESS there is an issue.
                            UseShellExecute = false, // cannot redirect output if it's running as shell execute
                        },
                    })
                    {
                        cmdKeyInitProcess.Start()
                            .AsArg(Invariant($"{nameof(cmdKeyInitProcess)}.{nameof(cmdKeyInitProcess.Start)}-must-return-true"))
                            .Must().BeTrue();
                        cmdKeyInitProcess.WaitForExit();
                        var cmdKeyInitOutput = cmdKeyInitProcess.StandardOutput.ReadToEnd();
                        var cmdKeyInitError = cmdKeyInitProcess.StandardError.ReadToEnd();
                        var cmdKeyInitExitCode = cmdKeyInitProcess.ExitCode;
                        if (cmdKeyInitExitCode != 0)
                        {
                            var cmdKeyInitFailedMessage =
                                Invariant(
                                    $"Failed to run {nameof(cmdKeyInitProcess)}; {Environment.NewLine}Console Out: {cmdKeyInitOutput}{Environment.NewLine}Console Error: {cmdKeyInitError}");
                            throw new ApplicationFailedException(cmdKeyInitFailedMessage);
                        }

                        activity.Write(() => Invariant($"Stored credentials temporarily stored using CMDKEY."));
                    }

                    var rdpArgs = shouldConnectInFullScreen ? Invariant($"/f /v {address}") : Invariant($"/v {address}");
                    var rdpProcess = new Process();
                    rdpProcess.StartInfo.FileName = Environment.ExpandEnvironmentVariables(@"%SystemRoot%\system32\mstsc.exe");
                    rdpProcess.StartInfo.Arguments = rdpArgs;
                    rdpProcess.Start().AsArg(Invariant($"{nameof(rdpProcess)}.{nameof(rdpProcess.Start)}-must-return-true"))
                        .Must().BeTrue();
                    activity.Write(() => Invariant($"Started MSTSC (Microsoft Terminal Services Client)."));

                    System.Threading.Thread.Sleep(TimeSpan
                        .FromSeconds(5)); // dirty way to make sure that MSTSC launches before cleaning the credentials...

                    using (var cmdKeyCleanupProcess = new Process
                    {
                        StartInfo = new ProcessStartInfo(
                            Environment.ExpandEnvironmentVariables(@"%SystemRoot%\system32\cmdkey.exe"),
                            Invariant($"/delete:TERMSRV/{address}"))
                        {
                            RedirectStandardOutput = true,
                            RedirectStandardError = true,
                            UseShellExecute = false,
                        },
                    })
                    {
                        cmdKeyCleanupProcess.Start()
                            .AsArg(Invariant(
                                $"{nameof(cmdKeyCleanupProcess)}.{nameof(cmdKeyCleanupProcess.Start)}-must-return-true")).Must()
                            .BeTrue();
                        cmdKeyCleanupProcess.WaitForExit();
                        var cmdKeyCleanupOutput = cmdKeyCleanupProcess.StandardOutput.ReadToEnd();
                        var cmdKeyCleanupError = cmdKeyCleanupProcess.StandardError.ReadToEnd();
                        var cmdKeyCleanupExitCode = cmdKeyCleanupProcess.ExitCode;
                        if (cmdKeyCleanupExitCode != 0)
                        {
                            var cmdKeyCleanupFailedMessage =
                                Invariant(
                                    $"Failed to run {nameof(cmdKeyCleanupProcess)}; {Environment.NewLine}Console Out: {cmdKeyCleanupOutput}{Environment.NewLine}Console Error: {cmdKeyCleanupError}");
                            throw new ApplicationFailedException(cmdKeyCleanupFailedMessage);
                        }

                        activity.Write(() => Invariant($"Removed credentials temporarily stored using CMDKEY."));
                    }

                    activity.Write(() => "Done - check for spawned window.");
                }
            }

            BootRunComputingManagerOperation(environmentType, Connect, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Starts the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="environment">Environment name where instance is located.</param>
        /// <param name="environmentType">Environment type.</param>
        public static void StartInstance(
            string credentialsJson,
            string infrastructureTrackerJson,
            string instanceName,
            string environment,
            EnvironmentType environmentType)
        {
            void StartInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => manager.GetInstanceDescriptionAsync(environment, instanceName);
                var instance = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                instance.AsArg(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                using (var activity = Log.With(() => new { instance.Name, instance.Id }))
                {
                    activity.Write(() => "Starting");
                    Func<Task> turnOnInstanceAsyncFunc = () => manager.TurnOnInstanceAsync(instance.Id, instance.Location);
                    turnOnInstanceAsyncFunc.ExecuteSynchronously();
                    activity.Write(() => "Running");
                }
            }

            BootRunComputingManagerOperation(environmentType, StartInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Stops the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="force">Force the shutdown.</param>
        /// <param name="environment">Environment name where instance is located.</param>
        /// <param name="environmentType">Environment type.</param>
        public static void StopInstance(
            string credentialsJson,
            string infrastructureTrackerJson,
            string instanceName,
            bool force,
            string environment,
            EnvironmentType environmentType)
        {
            void StopInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => manager.GetInstanceDescriptionAsync(environment, instanceName);
                var instance = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                instance.AsArg(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                using (var activity = Log.With(() => new { instance.Name, instance.Id }))
                {
                    activity.Write(() => "Stopping");
                    Func<Task> turnOffInstanceAsyncFunc = () => manager.TurnOffInstanceAsync(instance.Id, instance.Location, force);
                    turnOffInstanceAsyncFunc.ExecuteSynchronously();
                    activity.Write(() => "Stopped");
                }
            }

            BootRunComputingManagerOperation(environmentType, StopInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Stops then starts the instance found by name in provided tracker.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="instanceName">Name of the computer (short name - i.e. 'Database' NOT 'instance-Development-Database@us-west-1a').</param>
        /// <param name="force">Force the shutdown.</param>
        /// <param name="environment">Environment name where instance is located.</param>
        /// <param name="environmentType">Environment type.</param>
        public static void StopThenStartInstance(
            string credentialsJson,
            string infrastructureTrackerJson,
            string instanceName,
            bool force,
            string environment,
            EnvironmentType environmentType)
        {
            void StartInstance(ITrackComputingInfrastructure tracker, IManageComputingInfrastructure manager)
            {
                Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => manager.GetInstanceDescriptionAsync(environment, instanceName);
                var instance = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                instance.AsArg(Invariant($"FailedToFindInstanceByName-{instanceName}")).Must().NotBeNull();

                using (var activity = Log.With(() => new { instance.Name, instance.Id }))
                {
                    activity.Write(() => "Stopping");
                    Func<Task> turnOffInstanceAsyncFunc = () => manager.TurnOffInstanceAsync(instance.Id, instance.Location, force);
                    turnOffInstanceAsyncFunc.ExecuteSynchronously();
                    activity.Write(() => "Restarting");
                    Func<Task> turnOnInstanceAsync = () => manager.TurnOnInstanceAsync(instance.Id, instance.Location);
                    turnOnInstanceAsync.ExecuteSynchronously();
                    activity.Write(() => "Running");
                }
            }

            BootRunComputingManagerOperation(environmentType, StartInstance, credentialsJson, infrastructureTrackerJson);
        }

        /// <summary>
        /// Runs provided operation with <see cref="ITrackComputingInfrastructure" /> and <see cref="IManageComputingInfrastructure" /> using provided configs.
        /// </summary>
        /// <param name="environmentType">Type of environment.</param>
        /// <param name="action">Action to run.</param>
        /// <param name="credentialsJson">Credentials to use.</param>
        /// <param name="infrastructureTrackerJson">Tracker JSON.</param>
        public static void BootRunComputingManagerOperation(EnvironmentType environmentType, Action<ITrackComputingInfrastructure, IManageComputingInfrastructure> action, string credentialsJson, string infrastructureTrackerJson)
        {
            new { action }.AsArg().Must().NotBeNull();
            new { credentialsJson }.AsArg().Must().NotBeNull();
            new { infrastructureTrackerJson }.AsArg().Must().NotBeNull();

            var credentials = ConfigFileSerializer.Deserialize<CredentialContainer>(credentialsJson);
            var serializer = new ObcJsonSerializer<NaosDeploymentCoreJsonSerializationConfiguration>();
            var infrastructureTrackerConfiguration = (InfrastructureTrackerConfigurationBase)serializer.Deserialize(infrastructureTrackerJson, typeof(InfrastructureTrackerConfigurationBase));
            var computingInfrastructureManagerSettings = Config.Get<ComputingInfrastructureManagerSettings>(new SerializerRepresentation(SerializationKind.Json, typeof(NaosDeploymentCoreJsonSerializationConfiguration).ToRepresentation()));
            using (var infrastructureTracker = InfrastructureTrackerFactory.Create(infrastructureTrackerConfiguration))
            {
                using (var computingManager = GetComputingManager(environmentType, computingInfrastructureManagerSettings, infrastructureTracker, credentials))
                {
                    action(infrastructureTracker, computingManager);
                }
            }
        }

        /// <summary>
        /// Verifies the configuration repository.
        /// </summary>
        /// <param name="credentialsJson">The credentials json.</param>
        /// <param name="infrastructureTrackerJson">The infrastructure tracker json.</param>
        /// <param name="environment">The environment.</param>
        /// <param name="environmentType">Type of the environment.</param>
        /// <param name="configRepositoryPath">The configuration repository path.</param>
        /// <param name="nonPackageDeployments">The non package deployments.</param>
        /// <param name="adjustPackageIdToDeploymentConfigDirectoryName">Function to take the package identifier and return the deployment configuration directory name.</param>
        /// <param name="shouldIncludeByDecisionAgainstName">Function to take the instance name (short name) and determine if it should be included in the run.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "This will be refactored in the future but it will require improvements to various interfaces and it will wait until a larger refactoring is taking place.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode", Justification = "This will be refactored in the future but it will require improvements to various interfaces and it will wait until a larger refactoring is taking place.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "This will be refactored in the future but it will require improvements to various interfaces and it will wait until a larger refactoring is taking place.")]
        public static void VerifyConfigurationRepository(
            string credentialsJson,
            string infrastructureTrackerJson,
            string environment,
            EnvironmentType environmentType,
            string configRepositoryPath,
            IReadOnlyCollection<Tuple<string, DeploymentConfiguration>> nonPackageDeployments = null,
            Func<string, string> adjustPackageIdToDeploymentConfigDirectoryName = null,
            Func<string, bool> shouldIncludeByDecisionAgainstName = null)
        {
            if (!Directory.Exists(configRepositoryPath))
            {
                throw new DirectoryNotFoundException(Invariant($"Could not find configuration repository directory specified: '{configRepositoryPath}'."));
            }

            nonPackageDeployments = nonPackageDeployments ?? new Tuple<string, DeploymentConfiguration>[0];
            adjustPackageIdToDeploymentConfigDirectoryName = adjustPackageIdToDeploymentConfigDirectoryName ?? (_ => _);
            shouldIncludeByDecisionAgainstName = shouldIncludeByDecisionAgainstName ?? (_ => true);

            var serializer = new ObcJsonSerializer(typeof(NaosDeploymentCoreJsonSerializationConfiguration).ToJsonSerializationConfigurationType());
            var infrastructureTrackerConfiguration =
                (InfrastructureTrackerConfigurationBase)serializer.Deserialize(
                    infrastructureTrackerJson,
                    typeof(InfrastructureTrackerConfigurationBase));
            var credentials = (CredentialContainer)serializer.Deserialize(credentialsJson, typeof(CredentialContainer));
            var infrastructureManagerSettings = Config.Get<ComputingInfrastructureManagerSettings>(NaosDeploymentCoreJsonSerializationConfiguration.NaosDeploymentCoreJsonSerializerRepresentation);
            var computingInfrastructureManagerSettings = Config.Get<ComputingInfrastructureManagerSettings>(NaosDeploymentCoreJsonSerializationConfiguration.NaosDeploymentCoreJsonSerializerRepresentation);

            var nonPackageId = "NonPackageDeployment";

            using (var infrastructureTracker = InfrastructureTrackerFactory.Create(infrastructureTrackerConfiguration))
            {
                Func<Task<IReadOnlyCollection<InstanceDescription>>> allInstanceDescriptionsAsyncFunc = () => infrastructureTracker.GetAllInstanceDescriptionsAsync(environment);
                var allInstances = allInstanceDescriptionsAsyncFunc.ExecuteSynchronously();
                var instancesFilteredByName = allInstances.Where(_ => shouldIncludeByDecisionAgainstName(_.ComputerName)).ToList();
                var instancesToEvaluate = instancesFilteredByName.Select(
                    _ =>
                    {
                        var nonPackageDeployment = nonPackageDeployments.SingleOrDefault(__ => __.Item1 == _.ComputerName);
                        var packageId = nonPackageDeployment != null
                            ? nonPackageId + Guid.NewGuid().ToString().ToUpperInvariant()
                            : _.DeployedPackages
                               .Where(__ => !infrastructureManagerSettings.PackageIdsToIgnoreDuringTerminationSearch.Contains(__.Key))
                               .Select(__ => __.Key)
                               .SingleOrDefault();

                        _.SystemSpecificDetails.TryGetValue(nameof(OperatingSystem), out var operatingSystemText);
                        WindowsSku? windowsSku = null;
                        if (operatingSystemText?.StartsWith(nameof(WindowsSku), StringComparison.Ordinal) ?? false)
                        {
                            var treated = operatingSystemText.Replace(nameof(WindowsSku) + "-", string.Empty);
                            windowsSku = (WindowsSku)Enum.Parse(typeof(WindowsSku), treated);
                        }
                        else if (nonPackageDeployment != null && (nonPackageDeployment.Item2?.InstanceType?.OperatingSystem is OperatingSystemDescriptionWindows windowsOperatingSystem))
                        {
                            windowsSku = windowsOperatingSystem.Sku;
                        }

                        var hadWindowsSku = windowsSku != null;
                        var result = new
                        {
                            InstanceName = _.ComputerName,
                            OriginalAbstractInstanceType = nonPackageDeployment?.Item2?.InstanceType,
                            AbstractInstanceType = new InstanceType(),
                            PackageId = packageId,
                            OperatingSystemFromArcology = hadWindowsSku ? new OperatingSystemDescriptionWindows { Sku = (WindowsSku)windowsSku } : new OperatingSystemDescriptionWindows(),
                            OperatingSystemFromAws = new OperatingSystemDescriptionWindows(),
                        };

                        return result;
                    }).ToList();

                using (var computingManager = GetComputingManager(environmentType, computingInfrastructureManagerSettings, infrastructureTracker, credentials))
                {
                    foreach (var instanceToEvaluate in instancesToEvaluate)
                    {
                        Func<Task<InstanceDescription>> instanceDescriptionAsyncFunc = () => computingManager.GetInstanceDescriptionAsync(environment, instanceToEvaluate.InstanceName);
                        var description = instanceDescriptionAsyncFunc.ExecuteSynchronously();
                        var systemSpecificInstanceType = description.SystemSpecificDetails["instanceType"];
                        instanceToEvaluate.AbstractInstanceType.SpecificInstanceTypeSystemId = systemSpecificInstanceType;

                        description.SystemSpecificDetails.TryGetValue(nameof(OperatingSystem), out var operatingSystemText);
                        if (operatingSystemText?.StartsWith(nameof(WindowsSku), StringComparison.Ordinal) ?? false)
                        {
                            var treated = operatingSystemText.Replace(nameof(WindowsSku) + "-", string.Empty);
                            var windowsSku = (WindowsSku)Enum.Parse(typeof(WindowsSku), treated);
                            instanceToEvaluate.OperatingSystemFromAws.Sku = (WindowsSku)windowsSku;
                        }
                    }
                }

                var configs = Directory.GetDirectories(configRepositoryPath, "*.Deployment")
                                       .Select(
                                            _ => new
                                            {
                                                RootPath = _,
                                                DirectoryName = new DirectoryInfo(_).Name,
                                                DeploymentConfigPath = Path.Combine(
                                                         _,
                                                         Invariant($".config/{environment}/DeploymentConfigurationWithStrategies.json"))
                                            })
                                       .ToList();

                var deduplicatedInstancesToEvaluate = instancesToEvaluate.GroupBy(_ => _.PackageId).Select(
                    _ =>
                    {
                        if (_.Count() > 1)
                        {
                            string instanceType = null;
                            foreach (var item in _)
                            {
                                if (instanceType == null)
                                {
                                    instanceType = item.AbstractInstanceType.SpecificInstanceTypeSystemId;
                                }
                                else
                                {
                                    if (item.AbstractInstanceType.SpecificInstanceTypeSystemId != instanceType)
                                    {
                                        Console.WriteLine(Invariant($"Instance '{item.InstanceName}' has a type '{item.AbstractInstanceType.SpecificInstanceTypeSystemId}' but '{instanceType}' was expected."));
                                    }
                                }
                            }

                            return _.First();
                        }
                        else
                        {
                            return _.Single();
                        }
                    }).ToList();

                var patchedAbstractInstanceTypeInstancesToEvaluate = deduplicatedInstancesToEvaluate.Select(
                    _ =>
                    {
                        IReadOnlyCollection<AwsInstanceType> abstractInstanceTypes;
                        var windowsSkuArcology = _.OperatingSystemFromArcology.Sku;
                        var windowsSkuAws = _.OperatingSystemFromAws.Sku;
                        if (windowsSkuArcology != windowsSkuAws
                         && windowsSkuArcology != WindowsSku.DoesNotMatter
                         && windowsSkuAws != WindowsSku.DoesNotMatter)
                        {
                            Console.WriteLine(Invariant($"Unexpected that {_.InstanceName} has a {nameof(WindowsSku)} of '{windowsSkuArcology}' in Arcology but '{windowsSkuAws}' in AWS Tags."));
                        }

                        WindowsSku windowsSku;
                        if (windowsSkuArcology == WindowsSku.DoesNotMatter)
                        {
                            windowsSku = windowsSkuAws;
                        }
                        else
                        {
                            windowsSku = windowsSkuArcology;
                        }

                        if (windowsSku == WindowsSku.Base || windowsSku == WindowsSku.DoesNotMatter)
                        {
                            abstractInstanceTypes = computingInfrastructureManagerSettings.AwsInstanceTypes;
                        }
                        else if (windowsSku == WindowsSku.SqlWeb)
                        {
                            abstractInstanceTypes = computingInfrastructureManagerSettings.AwsInstanceTypesForSqlWeb;
                        }
                        else if (windowsSku == WindowsSku.SqlStandard)
                        {
                            abstractInstanceTypes = computingInfrastructureManagerSettings.AwsInstanceTypesForSqlStandard;
                        }
                        else
                        {
                            throw new NotSupportedException("This should not have been reached for " + _.InstanceName);
                        }

                        var matchingAbstractInstanceType = abstractInstanceTypes.SingleOrDefault(
                            __ => __.AwsInstanceTypeDescriptor == _.AbstractInstanceType.SpecificInstanceTypeSystemId);

                        if (matchingAbstractInstanceType != null)
                        {
                            _.AbstractInstanceType.VirtualCores = matchingAbstractInstanceType.VirtualCores;
                            _.AbstractInstanceType.RamInGb = matchingAbstractInstanceType.RamInGb;
                        }

                        return _;
                    }).ToList();

                foreach (var instanceToEvaluate in patchedAbstractInstanceTypeInstancesToEvaluate)
                {
                    if (instanceToEvaluate.PackageId?.StartsWith(nonPackageId, StringComparison.Ordinal) ?? false)
                    {
                        if (instanceToEvaluate.OriginalAbstractInstanceType.SpecificInstanceTypeSystemId
                         != instanceToEvaluate.AbstractInstanceType.SpecificInstanceTypeSystemId
                         && !(instanceToEvaluate.OriginalAbstractInstanceType.VirtualCores
                           == instanceToEvaluate.AbstractInstanceType.VirtualCores
                           && instanceToEvaluate.OriginalAbstractInstanceType.RamInGb
                           == instanceToEvaluate.AbstractInstanceType.RamInGb))
                        {
                            Console.WriteLine(Invariant($"FINISH WRITING NON PACKAGE ID CHECK AGAINST THINGY - {instanceToEvaluate.InstanceName}"));
                        }
                    }
                    else if (instanceToEvaluate.PackageId == null)
                    {
                        Console.WriteLine(Invariant($"! {instanceToEvaluate.InstanceName} did not have a package id."));
                    }
                    else
                    {
                        var configDirectoryName = adjustPackageIdToDeploymentConfigDirectoryName(instanceToEvaluate.PackageId);
                        var config = configs.SingleOrDefault(_ => _.DirectoryName == configDirectoryName);

                        if (config == null)
                        {
                            Console.WriteLine(Invariant($"! No config found {instanceToEvaluate.PackageId} on {instanceToEvaluate.InstanceName} expected to find: {configDirectoryName}"));
                        }
                        else
                        {
                            if (!File.Exists(config.DeploymentConfigPath))
                            {
                                Console.WriteLine(Invariant($"! Expected to find file '{config.DeploymentConfigPath}' but it did not exist."));
                            }
                            else
                            {
                                var configFileContents = File.ReadAllText(config.DeploymentConfigPath);
                                var configFileObject = serializer.Deserialize<DeploymentConfigurationWithStrategies>(configFileContents);
                                if (configFileObject.InstanceType.SpecificInstanceTypeSystemId != instanceToEvaluate.AbstractInstanceType.SpecificInstanceTypeSystemId)
                                {
                                    if (configFileObject.InstanceType.VirtualCores != instanceToEvaluate.AbstractInstanceType.VirtualCores
                                     && configFileObject.InstanceType.RamInGb != instanceToEvaluate.AbstractInstanceType.RamInGb)
                                    {
                                        Console.WriteLine(Invariant($"! Expected {config.DeploymentConfigPath} to have an instance type of {instanceToEvaluate.AbstractInstanceType} but found {configFileObject.InstanceType}"));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Deploys a new instance with specified packages.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="nugetPackageRepositoryConfigurationsJson">NuGet Repository/Gallery configurations.</param>
        /// <param name="certificateRetrieverJson">Certificate retriever configuration JSON.</param>
        /// <param name="infrastructureTrackerJson">Configuration for tracking system of computing infrastructure.</param>
        /// <param name="overrideDeploymentConfigJson">Optional deployment configuration to use as an override in JSON.</param>
        /// <param name="environmentCertificateName">Optional certificate name for an environment certificate saved in certificate manager being configured.</param>
        /// <param name="announcementFilePath">Optional announcement file path to write a JSON file of announcements (will overwrite if existing).</param>
        /// <param name="debugAnnouncementFilePath">Optional announcement file path to write a JSON file of debug announcements (will overwrite if existing)</param>
        /// <param name="telemetryFilePath">Optional telemetry file path to write a JSON file of certain step timings (will overwrite if existing).</param>
        /// <param name="nugetAnnouncementFilePath">Optional nuget file path to write a JSON file of output from nuget (will overwrite if existing).</param>
        /// <param name="instanceName">Optional name of the instance (one will be generated from the package list if not provided).</param>
        /// <param name="workingPath">Optional working directory for packages (default will be Temp Dir but might result in PathTooLongException).</param>
        /// <param name="packagesToDeployJson">Optional packages descriptions (with overrides) to configure the instance with.</param>
        /// <param name="existingDeploymentStrategy">Strategy for how to handle existing deployments.</param>
        /// <param name="deploymentAdjustmentApplicatorJson">Optional deployment adjustment strategies to use.</param>
        /// <param name="environment">Environment name being deployed to.</param>
        /// <param name="environmentType">Environment Type.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Most complicated set of steps, coupling ok here.")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "nuget", Justification = "Spelling/name is correct.")]
        public static void Deploy(
            string credentialsJson,
            string nugetPackageRepositoryConfigurationsJson,
            string certificateRetrieverJson,
            string infrastructureTrackerJson,
            string overrideDeploymentConfigJson,
            string environmentCertificateName,
            string announcementFilePath,
            string debugAnnouncementFilePath,
            string telemetryFilePath,
            string nugetAnnouncementFilePath,
            string instanceName,
            string workingPath,
            string packagesToDeployJson,
            ExistingDeploymentStrategy existingDeploymentStrategy,
            string deploymentAdjustmentApplicatorJson,
            string environment,
            EnvironmentType environmentType)
        {
            var machineManagerFactory = GetMachineManagerFactory(environmentType);
            var serializer = new ObcJsonSerializer<NaosDeploymentCoreJsonSerializationConfiguration>();
            var packagesToDeploy =
                (IReadOnlyCollection<PackageDescriptionWithOverrides>)serializer.Deserialize(
                    packagesToDeployJson,
                    typeof(IReadOnlyCollection<PackageDescriptionWithOverrides>));
            var certificateRetrieverConfiguration =
                (CertificateManagementConfigurationBase)serializer.Deserialize(
                    certificateRetrieverJson,
                    typeof(CertificateManagementConfigurationBase));
            var infrastructureTrackerConfiguration =
                (InfrastructureTrackerConfigurationBase)serializer.Deserialize(
                    infrastructureTrackerJson,
                    typeof(InfrastructureTrackerConfigurationBase));
            var deploymentAdjustmentStrategiesApplicator =
                (DeploymentAdjustmentStrategiesApplicator)serializer.Deserialize(
                    deploymentAdjustmentApplicatorJson,
                    typeof(DeploymentAdjustmentStrategiesApplicator));
            var credentials = (CredentialContainer)serializer.Deserialize(credentialsJson, typeof(CredentialContainer));

            var repoConfigs = (IReadOnlyCollection<PackageRepositoryConfiguration>)serializer.Deserialize(
                   nugetPackageRepositoryConfigurationsJson,
                typeof(IReadOnlyCollection<PackageRepositoryConfiguration>));
            var overrideConfig =
                (DeploymentConfiguration)serializer.Deserialize(overrideDeploymentConfigJson, typeof(DeploymentConfiguration));

            var setupFactorySettings = Config.Get<SetupStepFactorySettings>(NaosDeploymentCoreJsonSerializationConfiguration.NaosDeploymentCoreJsonSerializerRepresentation);
            var computingInfrastructureManagerSettings = Config.Get<ComputingInfrastructureManagerSettings>(NaosDeploymentCoreJsonSerializationConfiguration.NaosDeploymentCoreJsonSerializerRepresentation);
            var defaultDeploymentConfiguration = Config.Get<DefaultDeploymentConfiguration>(NaosDeploymentCoreJsonSerializationConfiguration.NaosDeploymentCoreJsonSerializerRepresentation);

            var certificateRetriever = CertificateManagementFactory.CreateReader(certificateRetrieverConfiguration);
            using (var infrastructureTracker = InfrastructureTrackerFactory.Create(infrastructureTrackerConfiguration))
            {
                using (var computingManager = GetComputingManager(environmentType, computingInfrastructureManagerSettings, infrastructureTracker, credentials))
                {
                    var tempDir = Path.GetTempPath();
                    var unzipDirPath = Path.Combine(tempDir, "Naos.Deployment.Temp");
                    if (!string.IsNullOrEmpty(workingPath))
                    {
                        unzipDirPath = workingPath;
                    }

                    if (Directory.Exists(unzipDirPath))
                    {
                        Using.LinearBackOff(TimeSpan.FromSeconds(5))
                            .WithMaxRetries(3)
                            .WithReporter(_ =>
                                Log.Write(() => _,
                                    Invariant($"Retrying delete deployment working directory {unzipDirPath} due to error.")))
                            .Run(() => Directory.Delete(unzipDirPath, true))
                            .Now();
                    }

                    Using.LinearBackOff(TimeSpan.FromSeconds(5))
                        .WithMaxRetries(3)
                        .WithReporter(_ =>
                            Log.Write(() => _,
                                Invariant($"Retrying create deployment working directory {unzipDirPath} due to error.")))
                        .Run(() => Directory.CreateDirectory(unzipDirPath))
                        .Now();

                    if (File.Exists(nugetAnnouncementFilePath))
                    {
                        File.Delete(nugetAnnouncementFilePath);
                    }

                    var configFileManager = new ConfigFileManager(
                        new[] { Config.CommonPrecedence },
                        Config.DefaultConfigDirectoryName,
                        ConfigFileSerializer);

                    using (var packageManager = new PackageRetriever(
                        unzipDirPath,
                        repoConfigs,
                        null,
                        s => NugetAnnouncementAction(s, nugetAnnouncementFilePath)))
                    {
                        var deploymentManager = new DeploymentManager(
                            infrastructureTracker,
                            computingManager,
                            packageManager,
                            certificateRetriever,
                            defaultDeploymentConfiguration,
                            setupFactorySettings,
                            deploymentAdjustmentStrategiesApplicator,
                            computingInfrastructureManagerSettings.PackageIdsToIgnoreDuringTerminationSearch,
                            Console.WriteLine,
                            line =>
                            {
                                /* no-op */
                            },
                            unzipDirPath,
                            configFileManager,
                            machineManagerFactory,
                            environmentCertificateName,
                            announcementFilePath,
                            debugAnnouncementFilePath,
                            telemetryFilePath);

                        deploymentManager.DeployPackagesAsync(packagesToDeploy, environment, instanceName, existingDeploymentStrategy, overrideConfig)
                            .Wait();
                    }
                }
            }
        }

        /// <summary>
        /// Upload a certificate to the arcology from a file along with additional information about it as well as encrypting information.
        /// </summary>
        /// <param name="certificateWriterJson">Certificate writer configuration JSON.</param>
        /// <param name="name">Name of the certificate to load.</param>
        /// <param name="pfxFilePath">File path to the certificate to load (in PFX file format).</param>
        /// <param name="clearTextPassword">Clear text password of the certificate to load.</param>
        /// <param name="certificateSigningRequestPemEncodedFilePath">File path to Certificate Signing Request (PEM encoded).</param>
        /// <param name="encryptingCertificateThumbprint">Thumbprint of the encrypting certificate.</param>
        /// <param name="encryptingCertificateIsValid">Value indicating whether or not the encrypting certificate is valid.</param>
        /// <param name="encryptingCertificateStoreName"><see cref="StoreName"/> to find the encrypting certificate.</param>
        /// <param name="encryptingCertificateStoreLocation"><see cref="StoreLocation"/> to find the encrypting certificate.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "pfx", Justification = "Spelling/name is correct.")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Pem", Justification = "Spelling/name is correct.")]
        public static void UploadCertificate(
            string certificateWriterJson,
            string name,
            string pfxFilePath,
            string clearTextPassword,
            string certificateSigningRequestPemEncodedFilePath,
            string encryptingCertificateThumbprint,
            bool encryptingCertificateIsValid,
            string encryptingCertificateStoreName,
            string encryptingCertificateStoreLocation)
        {
            new { name }.AsArg().Must().NotBeNullNorWhiteSpace();
            new { pfxFilePath }.AsArg().Must().NotBeNullNorWhiteSpace();
            new { clearTextPassword }.AsArg().Must().NotBeNullNorWhiteSpace();
            new { encryptingCertificateThumbprint }.AsArg().Must().NotBeNullNorWhiteSpace();

            if (!File.Exists(pfxFilePath))
            {
                throw new FileNotFoundException("Could not find specified PFX file path: " + pfxFilePath);
            }

            if (!string.IsNullOrWhiteSpace(certificateSigningRequestPemEncodedFilePath) &&
                !File.Exists(certificateSigningRequestPemEncodedFilePath))
            {
                throw new FileNotFoundException(
                    "Could not find specified Certificate Signing Request (PEM Encoded) file path: " +
                    certificateSigningRequestPemEncodedFilePath);
            }

            var serializer = new ObcJsonSerializer<NaosDeploymentCoreJsonSerializationConfiguration>();
            var certificateConfiguration =
                (CertificateManagementConfigurationBase)serializer.Deserialize(
                    certificateWriterJson,
                    typeof(CertificateManagementConfigurationBase));
            var writer = CertificateManagementFactory.CreateWriter(certificateConfiguration);

            var encryptingCertificateStoreNameEnum = encryptingCertificateStoreName == null
                ? CertificateLocator.DefaultCertificateStoreName
                : (StoreName)Enum.Parse(typeof(StoreName), encryptingCertificateStoreName);
            var encryptingCertificateStoreLocationEnum = encryptingCertificateStoreLocation == null
                ? CertificateLocator.DefaultCertificateStoreLocation
                : (StoreLocation)Enum.Parse(typeof(StoreLocation), encryptingCertificateStoreLocation);

            var encryptingCertificateLocator = new CertificateLocator(
                encryptingCertificateThumbprint,
                encryptingCertificateIsValid,
                encryptingCertificateStoreNameEnum,
                encryptingCertificateStoreLocationEnum);

            var bytes = File.ReadAllBytes(pfxFilePath);
            var certificateSigningRequestPemEncoded = certificateSigningRequestPemEncodedFilePath == null
                ? null
                : File.ReadAllText(certificateSigningRequestPemEncodedFilePath);

            var certToLoad =
                CertificateManagementFactory.BuildCertificateDescriptionWithClearPfxPayload(
                    name,
                    bytes,
                    clearTextPassword,
                    certificateSigningRequestPemEncoded);

            var cert = certToLoad.ToEncryptedVersion(encryptingCertificateLocator);

            Func<Task> persistCertificateAsyncFunc = () => writer.PersistCertificateAsync(cert);
            persistCertificateAsyncFunc.ExecuteSynchronously();
        }

        /// <summary>
        /// Gets the certificate from arcology.
        /// </summary>
        /// <param name="certificateName">Name of the certificate.</param>
        /// <param name="certificateRetrieverJson">The certificate retriever json.</param>
        /// <param name="exportFilePath">The export file path.</param>
        /// <returns>Password to file.</returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Arcology")]
        public static string GetCertificatePasswordAndWritePfxFileFromArcology(
            string certificateName,
            string certificateRetrieverJson,
            string exportFilePath)
        {
            var serializer = new ObcJsonSerializer(typeof(NaosDeploymentCoreJsonSerializationConfiguration).ToJsonSerializationConfigurationType());
            var certificateRetrieverConfiguration =
                (CertificateManagementConfigurationBase)serializer.Deserialize(
                    certificateRetrieverJson,
                    typeof(CertificateManagementConfigurationBase));

            var certificateRetriever = CertificateManagementFactory.CreateReader(certificateRetrieverConfiguration);
            Func<Task<CertificateDescriptionWithClearPfxPayload>> certificateByNameAsyncFunc = () => certificateRetriever.GetCertificateByNameAsync(certificateName);
            var arcologyCertificate = certificateByNameAsyncFunc.ExecuteSynchronously();

            File.WriteAllBytes(exportFilePath, arcologyCertificate.PfxBytes);
            return arcologyCertificate.PfxPasswordInClearText;
        }

        /// <summary>
        /// Creates a new environment.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="configFilePath">XML Serialized <see cref="ConfigEnvironment "/> describing assets to create.</param>
        /// <param name="outputArcologyPath">File path to create a file based arcology at.</param>
        /// <param name="computingPlatformKeyFilePath">Key file from computing provider for creating assets.</param>
        /// <param name="environmentCertificateFilePath">Certificate file to use for each machine.</param>
        /// <param name="environmentCertificatePassword">Password for environment certificate file.</param>
        /// <param name="deploymentCertificateFilePath">Certificate file to use for encrypting sensitive data.</param>
        /// <param name="deploymentCertificatePassword">Password for the deployment certificate file.</param>
        /// <param name="windowsSkuSearchPatternMapJson">Map of <see cref="WindowsSku" /> to search pattern to find appropriate instance template.</param>
        /// <param name="rootDomainHostingIdMapJson">Map of root domain to root hosting ID for computing platform.</param>
        /// <param name="environment">Environment to create.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Arcology", Justification = "Spelling/name is correct.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Ok for now.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Ok for now.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope", Justification = "Object is disposed.")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Sku", Justification = "Spelling/name is correct.")]
        public static void CreateEnvironment(
            string credentialsJson,
            string configFilePath,
            string outputArcologyPath,
            string computingPlatformKeyFilePath,
            string environmentCertificateFilePath,
            string environmentCertificatePassword,
            string deploymentCertificateFilePath,
            string deploymentCertificatePassword,
            string windowsSkuSearchPatternMapJson,
            string rootDomainHostingIdMapJson,
            string environment)
        {
            var serializer = ConfigFileSerializer;

            var outputConfigFilePath = Path.Combine(outputArcologyPath, Path.ChangeExtension(configFilePath, ".Created.xml") ?? throw new ArgumentException(Invariant($"Could not update extension of config file path because it was null.")));
            if (File.Exists(outputConfigFilePath))
            {
                var backupOutputConfigFilePath = Path.ChangeExtension(
                    outputConfigFilePath,
                    Invariant(
                        $".BackedUpOn{DateTime.UtcNow.ToString("yyyy-MM-dd--HH-mm-ss", CultureInfo.InvariantCulture)}Z.xml"));
                if (File.Exists(backupOutputConfigFilePath))
                {
                    throw new ArgumentException(Invariant($"Unexpected file present on disk: {backupOutputConfigFilePath}"));
                }

                File.Move(outputConfigFilePath, backupOutputConfigFilePath);
            }

            var environmentCertificateBytes = File.ReadAllBytes(environmentCertificateFilePath);
            var environmentCertificateChain =
                CertHelper.ExtractCryptographicObjectsFromPfxFile(environmentCertificateBytes, environmentCertificatePassword);
            var environmentCertificate = environmentCertificateChain.CertificateChain.GetEndUserCertFromCertChain();

            var deploymentCertificateBytes = File.ReadAllBytes(deploymentCertificateFilePath);
            var deploymentCertificateChain =
                CertHelper.ExtractCryptographicObjectsFromPfxFile(deploymentCertificateBytes, deploymentCertificatePassword);
            var deploymentCertificate = deploymentCertificateChain.CertificateChain.GetEndUserCertFromCertChain();
            var encryptingCertificateLocator = new CertificateLocator(deploymentCertificate.GetThumbprint(), false);

            // key text from Amazon does not actually work with the API out of the box...
            var keyName = Path.GetFileNameWithoutExtension(computingPlatformKeyFilePath);
            var keyText = File.ReadAllText(computingPlatformKeyFilePath);
            var keyHeader = "-----BEGIN RSA PRIVATE KEY-----";
            var keyFooter = "-----END RSA PRIVATE KEY-----";
            var cleanKeyText = Invariant(
                $"{keyHeader}{Environment.NewLine}{keyText.Replace(keyHeader, string.Empty).Replace(keyFooter, string.Empty).Replace(Environment.NewLine, string.Empty)}{Environment.NewLine}{keyFooter}");
            var encryptedKey = Encryptor.Encrypt(cleanKeyText, encryptingCertificateLocator);

            var rootDomainHostingIdMap = serializer.Deserialize<Dictionary<string, string>>(rootDomainHostingIdMapJson);
            var windowsSkuSearchPatternMap =
                serializer.Deserialize<Dictionary<WindowsSku, string>>(windowsSkuSearchPatternMapJson);

            var configFileXml = File.ReadAllText(configFilePath);
            var xmlSerializer = new XmlSerializer(typeof(ConfigEnvironment));
            ConfigEnvironment configuration;
            using (var stringReader = new StringReader(configFileXml))
            {
                configuration = (ConfigEnvironment)xmlSerializer.Deserialize(stringReader);
            }

            if (configuration.Vpcs.Length > 1)
            {
                throw new ArgumentException("Cannot create more than one VPC for use with an arcology.");
            }

            void UpdateOutputConfigFile(ConfigEnvironment updatedEnvironment)
            {
                using (var stringWriter = new StringWriter(CultureInfo.InvariantCulture))
                {
                    xmlSerializer.Serialize(stringWriter, updatedEnvironment);
                    File.WriteAllText(outputConfigFilePath, stringWriter.ToString());
                }
            }

            var credentials = serializer.Deserialize<CredentialContainer>(credentialsJson);
            Func<Task<ConfigEnvironment>> createEnvironmentFunc = () => Creator.CreateEnvironment(
                                                                      credentials,
                                                                      configuration,
                                                                      UpdateOutputConfigFile,
                                                                      null,
                                                                      TimeSpan.FromMinutes(10));

            var populatedEnvironment = createEnvironmentFunc.ExecuteSynchronously();

            var vpc = populatedEnvironment.Vpcs.Single();

            var computingContainers = vpc.Subnets.Where(
                _ => _.Name.ToUpperInvariant().Contains(InstanceAccessibility.Public.ToString().ToUpperInvariant())
                     || _.Name.ToUpperInvariant().Contains(InstanceAccessibility.Private.ToString().ToUpperInvariant())
                     || _.Name.ToUpperInvariant().Contains("VPN")).Select(
                subnet =>
                {
                    var routeTable = vpc.RouteTables.Single(_ =>
                        _.Name.Equals(subnet.RouteTableRef, StringComparison.CurrentCultureIgnoreCase));
                    var accessiblity =
                        routeTable.Routes.Any(
                            route => populatedEnvironment.InternetGateways.Any(
                                gateway => route.TargetRef.Equals(gateway.Name, StringComparison.CurrentCultureIgnoreCase)))
                            ? (subnet.Name.ToUpperInvariant().Contains("VPN")
                                ? InstanceAccessibility.Tunnel
                                : InstanceAccessibility.Public)
                            : InstanceAccessibility.Private;

                    var securityGroup = vpc.SecurityGroups.Single();

                    var container = new ComputingContainerDescription
                    {
                        Cidr = subnet.Cidr,
                        ContainerLocation = subnet.AvailabilityZone,
                        ContainerId = subnet.SubnetId,
                        InstanceAccessibility = accessiblity,
                        SecurityGroupId = securityGroup.SecurityGroupId,
                        StartIpsAfter = 10,
                        EncryptingCertificateLocator = encryptingCertificateLocator,
                        KeyName = keyName,
                        EncryptedPrivateKey = encryptedKey,
                    };

                    return container;
                }).ToList();

            var outputConfigText = File.ReadAllText(outputConfigFilePath);
            var arcologyInfo = new ArcologyInfo
            {
                Location = populatedEnvironment.RegionName,
                SerializedEnvironmentSpecification = outputConfigText,
                ComputingContainers = computingContainers,
                RootDomainHostingIdMap = rootDomainHostingIdMap,
                WindowsSkuSearchPatternMap = windowsSkuSearchPatternMap,
            };

            if (!Directory.Exists(outputArcologyPath))
            {
                Directory.CreateDirectory(outputArcologyPath);
            }

            using (var newFileArcology = new RootFolderEnvironmentFolderInstanceFileTracker(outputArcologyPath))
            {
                Func<Task> createFileArcologyFunc = () => newFileArcology.Create(environment, arcologyInfo);
                createFileArcologyFunc.ExecuteSynchronously();
            }

            var certificatesJsonFilePath = Path.Combine(outputArcologyPath, Invariant($"{environment}.Certificates.json"));
            CertificateWriterToFile.Create(certificatesJsonFilePath);

            var certificateWriter = new CertificateWriterToFile(certificatesJsonFilePath);
            var environmentCertToStore = new CertificateDescriptionWithClearPfxPayload(
                Path.GetFileNameWithoutExtension(environmentCertificateFilePath),
                environmentCertificate.GetThumbprint(),
                environmentCertificate.GetValidityPeriod(),
                environmentCertificate.GetX509SubjectAttributes().ToDictionary(k => k.Key.ToString(), v => v.Value),
                environmentCertificateBytes,
                environmentCertificatePassword);

            Func<Task> persistEnvironmentCertificateAsyncFunc =
                () => certificateWriter.PersistCertificateAsync(environmentCertToStore, encryptingCertificateLocator);
            persistEnvironmentCertificateAsyncFunc.ExecuteSynchronously();

            var deploymentCertToStore = new CertificateDescriptionWithClearPfxPayload(
                Path.GetFileNameWithoutExtension(deploymentCertificateFilePath),
                deploymentCertificate.GetThumbprint(),
                deploymentCertificate.GetValidityPeriod(),
                deploymentCertificate.GetX509SubjectAttributes().ToDictionary(k => k.Key.ToString(), v => v.Value),
                deploymentCertificateBytes,
                deploymentCertificatePassword);
            Func<Task> persistDeploymentCertificateAsyncFunc =
                () => certificateWriter.PersistCertificateAsync(deploymentCertToStore, encryptingCertificateLocator);
            persistDeploymentCertificateAsyncFunc.ExecuteSynchronously();
        }

        /// <summary>
        /// Destroy an existing environment.
        /// </summary>
        /// <param name="credentialsJson">Credentials for the computing platform provider to use in JSON.</param>
        /// <param name="configFilePath">XML Serialized <see cref="ConfigEnvironment "/> describing assets to destroy.</param>
        /// <param name="environment">Environment to destroy.</param>
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "arcology", Justification = "Spelling/name is correct.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Ok for now.")]
        public static void DestroyEnvironment(string credentialsJson, string configFilePath, string environment)
        {
            new { credentialsJson }.AsArg().Must().NotBeNullNorWhiteSpace();
            new { configFilePath }.AsArg().Must().NotBeNullNorWhiteSpace();

            var serializer = ConfigFileSerializer;
            var credentials = serializer.Deserialize<CredentialContainer>(credentialsJson);

            var configFileXml = File.ReadAllText(configFilePath);
            var xmlSerializer = new XmlSerializer(typeof(ConfigEnvironment));
            ConfigEnvironment configuration;
            using (var stringReader = new StringReader(configFileXml))
            {
                configuration = (ConfigEnvironment)xmlSerializer.Deserialize(stringReader);
            }

            if (configuration.Vpcs.Length > 1)
            {
                throw new ArgumentException("Cannot create more than one VPC for use with an arcology.");
            }

            var cidr = configuration.Vpcs.Single().Cidr;
            Func<Task<IList<InstanceWithStatus>>> fillFromAwsTask = () => new List<InstanceWithStatus>().FillFromAwsAsync(configuration.RegionName, credentials);
            var instances = fillFromAwsTask.ExecuteSynchronously();

            // MUST filter by terminated first because AWS will return null IP addresses which will through on the next filter step...
            var nonTerminatedInstances = instances
                .Where(_ => _.InstanceStatus.InstanceState != Naos.AWS.Domain.InstanceState.Terminated)
                .Where(_ => ArcologyInfo.IsIpAddressInRange(_.PrivateIpAddress, cidr));
            if (nonTerminatedInstances.Any())
            {
                throw new ArgumentException(Invariant(
                    $"Cannot destroy an environment with instances! {environment} has {string.Join(",", instances.Select(_ => _.PrivateIpAddress))}.  If this is intended for destruction then first retire each instance."));
            }

            var outputConfigFilePath = Path.ChangeExtension(configFilePath, ".Removed.xml");
            if (File.Exists(outputConfigFilePath))
            {
                var backupOutputConfigFilePath = Path.ChangeExtension(
                    outputConfigFilePath,
                    Invariant(
                        $".BackedUpOn{DateTime.UtcNow.ToString("yyyy-MM-dd--HH-mm-ss", CultureInfo.InvariantCulture)}Z.xml"));
                if (File.Exists(backupOutputConfigFilePath))
                {
                    throw new ArgumentException(Invariant($"Unexpected file present on disk: {backupOutputConfigFilePath}"));
                }

                File.Move(outputConfigFilePath, backupOutputConfigFilePath);
            }

            void UpdateOutputConfigFile(ConfigEnvironment updatedEnvironment)
            {
                using (var stringWriter = new StringWriter(CultureInfo.InvariantCulture))
                {
                    xmlSerializer.Serialize(stringWriter, updatedEnvironment);
                    File.WriteAllText(outputConfigFilePath, stringWriter.ToString());
                }
            }

            Func<Task<ConfigEnvironment>> removeEnvironmentTask = () => Destroyer.RemoveEnvironment(
                                                                      credentials,
                                                                      configuration,
                                                                      UpdateOutputConfigFile,
                                                                      null,
                                                                      TimeSpan.FromMinutes(10));
            var destroyedEnvironment = removeEnvironmentTask.ExecuteSynchronously();
            if (destroyedEnvironment.Vpcs.Any() || destroyedEnvironment.InternetGateways.Any() ||
                destroyedEnvironment.ElasticIps.Any())
            {
                var serializedDestroyedEnvironment = ConfigFileSerializer.SerializeToString(destroyedEnvironment);
                throw new DeploymentException("Unexpected remaining items in arcology after destruction; " + Environment.NewLine + serializedDestroyedEnvironment);
            }
        }

        [SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
        internal static IManageComputingInfrastructure GetComputingManager(
            EnvironmentType environmentType,
            ComputingInfrastructureManagerSettings computingInfrastructureManagerSettings,
            ITrackComputingInfrastructure infrastructureTracker,
            CredentialContainer credentials)
        {
            switch (environmentType)
            {
                case EnvironmentType.Aws:
                    var result = new ComputingInfrastructureManagerForAws(
                        computingInfrastructureManagerSettings,
                        infrastructureTracker);
                    result.InitializeCredentials(credentials);
                    return result;
                case EnvironmentType.Manual:
                    return new NullComputingManager();
                default:
                    throw new NotSupportedException(Invariant($"Environment type: {environmentType} is not supported."));
            }
        }

        /// <summary>
        /// Gets the machine manager factory.
        /// </summary>
        /// <param name="environmentType">Type of the environment.</param>
        /// <returns>ICreateMachineManagers.</returns>
        public static ICreateMachineManagers GetMachineManagerFactory(
            EnvironmentType environmentType)
        {
            switch (environmentType)
            {
                case EnvironmentType.Aws:
                    return new MachineManagerFactory();
                case EnvironmentType.Manual:
                    // TODO: Need to unify this with config of deployment directory.
                    var path = @"D:\Deployments\";
                    if (!Directory.Exists(path))
                    {
                        Directory.CreateDirectory(path);
                    }
                    return new RecordingMachineManagerFactory(path);
                default:
                    throw new NotSupportedException(Invariant($"Environment type: {environmentType} is not supported."));
            }
        }
    }
}