// --------------------------------------------------------------------------------------------------------------------
// <copyright file="CertHelper.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Security.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Security.Recipes
{
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Globalization;
    using global::System.IO;
    using global::System.Linq;
    using global::System.Security.Cryptography;
    using global::System.Security.Cryptography.Pkcs;
    using global::System.Security.Cryptography.X509Certificates;
    using global::System.Text;
    using global::System.Text.RegularExpressions;
    using OBeautifulCode.CodeAnalysis.Recipes;
    using OBeautifulCode.Type;
    using Org.BouncyCastle.Asn1;
    using Org.BouncyCastle.Asn1.Pkcs;
    using Org.BouncyCastle.Asn1.X509;
    using Org.BouncyCastle.Cms;
    using Org.BouncyCastle.Crypto;
    using Org.BouncyCastle.Crypto.Generators;
    using Org.BouncyCastle.Crypto.Operators;
    using Org.BouncyCastle.Crypto.Parameters;
    using Org.BouncyCastle.Math;
    using Org.BouncyCastle.OpenSsl;
    using Org.BouncyCastle.Pkcs;
    using Org.BouncyCastle.Security;
    using Org.BouncyCastle.X509;
    using Org.BouncyCastle.X509.Extension;
    using static global::System.FormattableString;
    using ContentInfo = global::System.Security.Cryptography.Pkcs.ContentInfo;
    using X509Certificate = Org.BouncyCastle.X509.X509Certificate;
    using X509Extension = Org.BouncyCastle.Asn1.X509.X509Extension;

    /// <summary>
    /// Provides helpers methods for dealing with certificates.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "There are a lot of things you can do with certs!  Should really break this up...")]
#if !OBeautifulCodeSecuritySolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Security.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class CertHelper
    {
        /// <summary>
        /// Well known PEM-encoded certificate to be used in testing pipelines that utilize encryption/decryption logic.
        /// </summary>
        public const string PemEncodedTestingX509Certificate = @"-----BEGIN CERTIFICATE-----
MIID3TCCAsWgAwIBAgIICNr9aI9GVzswDQYJKoZIhvcNAQEFBQAwbjEOMAwGA1UE
BhMFd29ybGQxDjAMBgNVBAgMBXdvcmxkMQ4wDAYDVQQHDAV3b3JsZDEMMAoGA1UE
CgwDb2JjMQwwCgYDVQQLDANvYmMxIDAeBgNVBAMMF251bGwub2JlYXV0aWZ1bGNv
ZGUuY29tMB4XDTIzMDEyMzE3Mzc1NFoXDTMzMDEyMzE3Mzc1NFowbjEOMAwGA1UE
BhMFd29ybGQxDjAMBgNVBAgMBXdvcmxkMQ4wDAYDVQQHDAV3b3JsZDEMMAoGA1UE
CgwDb2JjMQwwCgYDVQQLDANvYmMxIDAeBgNVBAMMF251bGwub2JlYXV0aWZ1bGNv
ZGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAm5t23jDHTAop
fDiUgc90dlqjpZdYtkTSuBXzFVkG0/YUDb9sREPlAL9nu4RayaOUn8vY0xjoX/4G
oitMNhMS2VQ8pBosjcmMd1vfijmu8V/ogKyeQlNoHCPvMogPMKVl5tyCgBotCEHL
9x4cZdHucSCxaH4tGVcXL1GYaVihSSyICs81B8gl3WO3wecfuvZM+3aGdV+r/hBy
flNscNGraXCOhArRt0IbLBwc80L1irvuh/KUNdmzTOIRgOd93nLmb8iT8iD5SL/H
oiH09G1dMLZ6+3Mj+riM5h+UUJ/+ZWLUMw/ntWVUPmrt2RmpzNJgopJCH8I+wb2s
zaC7RUvPEwIDAQABo38wfTAMBgNVHRMBAf8EAjAAMA4GA1UdDwEB/wQEAwIE8DAd
BgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwHQYDVR0OBBYEFNPdjjeBm6/Z
9Jrxm7q8vIqVYfz1MB8GA1UdIwQYMBaAFNPdjjeBm6/Z9Jrxm7q8vIqVYfz1MA0G
CSqGSIb3DQEBBQUAA4IBAQCFO0nI+Run9B8r14v4qcoBAj8p8XGL11m58Vev1n6z
9NDb9YyowJvLv50PoVPI3986TVhG57iZGCm9ta3mXMgZIIjq8mSXYXWEYMoMX0Pc
6MRHMHyG3Z+abcQwrnU1+5WRmB6x/N5ttisojfWFBg+wpDXYAG32I7XvuaR/gmXE
kLF3AkTzXrxeKScmgMbxv88uWdqXCUX0ulVFctKpyYaOZYLroUvHkmmqqclkxfRl
kG1s4U/9yeApODVOuDhLDESamLuy04fd9hSCmRvcAafsOTI9fW0ZF5MVYj6ed0eA
X/ai7AWl465ZUyuIM1nfW2bToJA1KdOLjGMaGDS1EMcL
-----END CERTIFICATE-----
";

        /// <summary>
        /// Well known PEM-encoded private key, to be used in testing pipelines that utilize encryption/decryption logic.
        /// </summary>
        public const string PemEncodedTestingPrivateKey = @"-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAm5t23jDHTAopfDiUgc90dlqjpZdYtkTSuBXzFVkG0/YUDb9s
REPlAL9nu4RayaOUn8vY0xjoX/4GoitMNhMS2VQ8pBosjcmMd1vfijmu8V/ogKye
QlNoHCPvMogPMKVl5tyCgBotCEHL9x4cZdHucSCxaH4tGVcXL1GYaVihSSyICs81
B8gl3WO3wecfuvZM+3aGdV+r/hByflNscNGraXCOhArRt0IbLBwc80L1irvuh/KU
NdmzTOIRgOd93nLmb8iT8iD5SL/HoiH09G1dMLZ6+3Mj+riM5h+UUJ/+ZWLUMw/n
tWVUPmrt2RmpzNJgopJCH8I+wb2szaC7RUvPEwIDAQABAoIBABPSe5N1WkX8+2jo
Gj7pCvhytmsHOxVI8iDiJuuewihpLgfMTUHq9jagq1mvVBNgo7Oxd4b4os1rojOx
WU2AI4QM34a2ENvlA2BHE1Rb4cW8xnTxyF1Bm78N8tAYlfrH7xG4IGWqL/dfzlhF
/S8ZTYsas47Ql/Uk636rIcO1tyIHdq0QtF36XTOP1pQXUkiA2gDZjGoFmf09RdZk
+8avzOQJ0jYhPDvIdU78EIah5rCsehgJIo1Od08lX942KXCpWwAQ/n6FJCj7/P/W
4b66jrQblBnnU7acUjPHJSOLNY6dL8yT8gJx/7k2X3U8uFJBDe6U6M6H5bVGOBwQ
Friej10CgYEA90+aFgJRjt7NPQxpLMd4Gr5XBLyTyt/Wg8Rfd5m0J36rT/UsoEyA
Pz5jSuazDup+51JB/ECD00rVMddWYsZRctgU/QhP4IrAZyvtCWmzesoHGaITeoBd
TI4qxsTkgD5wKWl4dAgyk77KXfw43bmtLMcbEsKPe5b2PArLeiYGBRUCgYEAoRMM
elVtqToDiD/WKI657gz+eSoVs/w6HTk2/5kj/5c4KoVBoDi1GZiWM0d4YwsoyBZM
Sc/8ZLQwMspUoaOJTmJMzSCQRFuvAadB+v5GW+7+fMtLGRzkFKjOnPu5AYHzpquc
IB63geQgSdZ2vkbVaJxg/NDjVbS9TzyIelXM3YcCgYBdP+eCmvcznrDWbwKNPtz7
gH+BKrWzTjktT/MLPqpeJfXkXTapbo8Ayb5YtKoZWrPk9vAodA8AsXu3olFRRyPY
4L7xNZwgt1Ca1kY3QWLKTrjkomcjzpjfT8+zSPQ7os9Z3gnr/ldLvCnDzGGIwQUa
GC0OIsxFNoO72folIYctjQKBgBX7c4h+gCjIMhM2IxQF5noGa/Q9OhkGIyg51rer
Pq5zBMdIyFwFYTHNETKOXm+l5jroUCECsX9M2AcWddZZazO3VqPn/chWetvO58JJ
UXDafQCq/eS/fKEVKJ1j/SungIkOgpAfoQupBn8NNcdiA13zeYkHOP9JW0ylBjsr
2nmhAoGBAIoGr0fsgcjTYrSlZ28xqQFqVUrLfgVcqcB2TSIN45nvwgR4uS8pLWoL
axMwXI9epEe+G83SjSJJFFDeQI6H8hS/0jT8kM8/+nV5Awjv5HWq+4F8okHslNn/
nnoh6+yENZjm2uk8sW3Oqal8sqvx57tthV9+x/OGeH8+vcviGefx
-----END RSA PRIVATE KEY-----
";

        /// <summary>
        /// Well known certificate to be used in testing pipelines that utilize encryption/decryption logic.
        /// </summary>
        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes", Justification = ObcSuppressBecause.CA2104_DoNotDeclareReadOnlyMutableReferenceTypes_TypeIsImmutable)]
        public static X509Certificate2 TestingX509Certificate => ReadCertsFromPemEncodedString(PemEncodedTestingX509Certificate).Single();

        /// <summary>
        /// Well known PKCS #12 certificate (bundles private key with X.509 certificate) to be used in testing pipelines that utilize encryption/decryption logic.
        /// </summary>
        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes", Justification = ObcSuppressBecause.CA2104_DoNotDeclareReadOnlyMutableReferenceTypes_TypeIsImmutable)]
        public static X509Certificate2 Pkcs12TestingCertificate => ReadPkcs12CertFromPemEncodedStrings(PemEncodedTestingX509Certificate, PemEncodedTestingPrivateKey);

        /// <summary>
        /// Creates an AWS Certificate Manager payload from a PFX file.
        /// </summary>
        /// <param name="input">A byte array of the PFX.</param>
        /// <param name="clearTextPassword">The PFX password in clear-text.</param>
        /// <returns>
        /// A payload that can be used to load certs into the AWS Certificate Manager via the console.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        /// <exception cref="InvalidOperationException">The PFX file does not contain a private key.</exception>
        public static AwsCertificateManagerPayload CreateAwsCertificateManagerPayloadFromPfx(
            byte[] input,
            string clearTextPassword)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            var extractedPfxFile = ExtractCryptographicObjectsFromPfxFile(input, clearTextPassword);

            if (extractedPfxFile.PrivateKey == null)
            {
                throw new InvalidOperationException(Invariant($"{nameof(extractedPfxFile)}.{nameof(ExtractedPfxFile.PrivateKey)} is null"));
            }

            var endUserCertificate = extractedPfxFile.CertificateChain.GetEndUserCertFromCertChain();

            var intermediateCertChain = extractedPfxFile.CertificateChain.GetIntermediateChainFromCertChain();

            var result = new AwsCertificateManagerPayload(endUserCertificate.AsPemEncodedString(), extractedPfxFile.PrivateKey.AsPemEncodedString(), intermediateCertChain.AsPemEncodedString());

            return result;
        }

        /// <summary>
        /// Creates a PFX file.
        /// </summary>
        /// <param name="pemEncodedIntermediateCertificateChainFilePath">Path to a PEM-encoded intermediate certificate chain (often with a 'ca-bundle' extension or file name contains 'bundle').</param>
        /// <param name="pemEncodedCertificateFilePath">Path to PEM-encoded certificate (often with a 'crt' extension).</param>
        /// <param name="clearTextPassword">The password for the PFX file.</param>
        /// <param name="outputPfxFilePath">The path to write the PFX file to.</param>
        /// <param name="overwrite">
        /// Determines whether to overwrite a file that already exist at <paramref name="outputPfxFilePath"/>.
        /// If false and a file exists at that path, the method will throw.
        /// </param>
        /// <param name="pemEncodedPrivateKeyFilePath">Optional path to PEM-encoded private key.  Default is null, no private key specified.</param>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedIntermediateCertificateChainFilePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedIntermediateCertificateChainFilePath"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedCertificateFilePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedCertificateFilePath"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="outputPfxFilePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="outputPfxFilePath"/> is white space.</exception>
        /// <exception cref="IOException"><paramref name="overwrite"/> is false and there is a file at <paramref name="outputPfxFilePath"/>.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Creating a PFX requires lots of types.")]
        public static void CreatePfxFile(
            string pemEncodedIntermediateCertificateChainFilePath,
            string pemEncodedCertificateFilePath,
            string clearTextPassword,
            string outputPfxFilePath,
            bool overwrite,
            string pemEncodedPrivateKeyFilePath = null)
        {
            if (pemEncodedIntermediateCertificateChainFilePath == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedIntermediateCertificateChainFilePath));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedIntermediateCertificateChainFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedIntermediateCertificateChainFilePath)}' is white space"));
            }

            if (pemEncodedCertificateFilePath == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedCertificateFilePath));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedCertificateFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedCertificateFilePath)}' is white space"));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            if (outputPfxFilePath == null)
            {
                throw new ArgumentNullException(nameof(outputPfxFilePath));
            }

            if (string.IsNullOrWhiteSpace(outputPfxFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(outputPfxFilePath)}' is white space"));
            }

            var pemEncodedIntermediateCertificateChain = File.ReadAllText(pemEncodedIntermediateCertificateChainFilePath);

            var intermediateCertificateChain = ReadCertsFromPemEncodedString(pemEncodedIntermediateCertificateChain);

            var pemEncodedCertificate = File.ReadAllText(pemEncodedCertificateFilePath);

            var certificate = ReadCertsFromPemEncodedString(pemEncodedCertificate);

            AsymmetricKeyParameter privateKey = null;

            if (!string.IsNullOrWhiteSpace(pemEncodedPrivateKeyFilePath))
            {
                var pemEncodedPrivateKey = File.ReadAllText(pemEncodedPrivateKeyFilePath);

                privateKey = ReadPrivateKeyFromPemEncodedString(pemEncodedPrivateKey);
            }

            var certChain = certificate.Concat(intermediateCertificateChain.OrderCertChainFromLowestToHighestLevelOfTrust()).ToList();

            CreatePfxFile(certChain, clearTextPassword, outputPfxFilePath, overwrite, privateKey);
        }

        /// <summary>
        /// Creates a PFX file.
        /// </summary>
        /// <param name="certChain">The cert chain.  The order of the certificates is inconsequential.</param>
        /// <param name="clearTextPassword">The password for the PFX file.</param>
        /// <param name="outputPfxFilePath">The path to write the PFX file to.</param>
        /// <param name="overwrite">
        /// Determines whether to overwrite a file that already exist at <paramref name="outputPfxFilePath"/>.
        /// If false and a file exists at that path, the method will throw.
        /// </param>
        /// <param name="privateKey">Optional private key to include in the PFX.</param>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="outputPfxFilePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="outputPfxFilePath"/> is white space.</exception>
        /// <exception cref="ArgumentException"><paramref name="privateKey"/> is not null and not private.</exception>
        /// <exception cref="IOException"><paramref name="overwrite"/> is false and there is a file at <paramref name="outputPfxFilePath"/>.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Creating a PFX requires lots of types.")]
        public static void CreatePfxFile(
            IReadOnlyList<X509Certificate2> certChain,
            string clearTextPassword,
            string outputPfxFilePath,
            bool overwrite,
            AsymmetricKeyParameter privateKey = null)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            if (outputPfxFilePath == null)
            {
                throw new ArgumentNullException(nameof(outputPfxFilePath));
            }

            if (string.IsNullOrWhiteSpace(outputPfxFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(outputPfxFilePath)}' is white space"));
            }

            if (privateKey != null)
            {
                if (!privateKey.IsPrivate)
                {
                    throw new ArgumentException(Invariant($"'{nameof(privateKey.IsPrivate)}' is false"));
                }
            }

            var mode = overwrite ? FileMode.Create : FileMode.CreateNew;

            using (var fileStream = new FileStream(outputPfxFilePath, mode, FileAccess.Write, FileShare.None))
            {
                CreatePfxFile(certChain, clearTextPassword, fileStream, privateKey);
            }
        }

        /// <summary>
        /// Creates a PFX file.
        /// </summary>
        /// <remarks>
        /// adapted from: <a href="https://boredwookie.net/blog/m/bouncy-castle-create-a-basic-certificate" />.
        /// </remarks>
        /// <param name="certChain">The cert chain.  The order of the certificates is inconsequential.</param>
        /// <param name="clearTextPassword">The password for the PFX file.</param>
        /// <param name="output">The stream to write the PFX file to.</param>
        /// <param name="privateKey">Optional private key to include in the PFX.</param>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="output"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="output"/> is not writable.</exception>
        /// <exception cref="ArgumentException"><paramref name="privateKey"/> is not null and not private.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Creating a PFX requires lots of types.")]
        public static void CreatePfxFile(
            IReadOnlyList<X509Certificate2> certChain,
            string clearTextPassword,
            Stream output,
            AsymmetricKeyParameter privateKey = null)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            if (output == null)
            {
                throw new ArgumentNullException(nameof(output));
            }

            if (!output.CanWrite)
            {
                throw new ArgumentException(Invariant($"'{nameof(output.CanWrite)}' is false"));
            }

            if (privateKey != null)
            {
                if (!privateKey.IsPrivate)
                {
                    throw new ArgumentException(Invariant($"'{nameof(privateKey.IsPrivate)}' is false"));
                }
            }

            certChain = certChain.OrderCertChainFromLowestToHighestLevelOfTrust();

            var store = new Pkcs12StoreBuilder().Build();

            var certEntries = new List<X509CertificateEntry>();

            foreach (var cert in certChain)
            {
                var certEntry = new X509CertificateEntry(cert.ToBouncyX509Certificate());

                certEntries.Add(certEntry);

                var certSubjectAttributes = cert.GetX509SubjectAttributes();

                var certStoreKey = certSubjectAttributes[X509SubjectAttributeKind.CommonName];

                store.SetCertificateEntry(certStoreKey, certEntry);
            }

            if (privateKey != null)
            {
                var keyEntry = new AsymmetricKeyEntry(privateKey);

                var firstCert = certChain.First();

                var firstCertSubjectAttributes = firstCert.GetX509SubjectAttributes();

                store.SetKeyEntry(firstCertSubjectAttributes[X509SubjectAttributeKind.CommonName], keyEntry, certEntries.ToArray());
            }

            store.Save(output, clearTextPassword.ToCharArray(), new SecureRandom());
        }

        /// <summary>
        /// Creates an RSA asymmetric cipher key pair.
        /// </summary>
        /// <param name="rsaKeyLength">The length of the rsa key (e.g. 2048 bits).</param>
        /// <returns>
        /// A RSA asymmetric cipher key pair.
        /// </returns>
        public static AsymmetricCipherKeyPair CreateRsaKeyPair(
            int rsaKeyLength = 2048)
        {
            var rsaKeyPairGenerator = new RsaKeyPairGenerator();

            rsaKeyPairGenerator.Init(new KeyGenerationParameters(new SecureRandom(), rsaKeyLength));

            var keyPair = rsaKeyPairGenerator.GenerateKeyPair();

            return keyPair;
        }

        /// <summary>
        /// Creates a certificate signing request for an SSL certificate.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://gist.github.com/Venomed/5337717aadfb61b09e58" />.
        /// </remarks>
        /// <param name="asymmetricKeyPair">The asymmetric cipher key pair.</param>
        /// <param name="commonName">The common name (e.g. "example.com").</param>
        /// <param name="subjectAlternativeNames">Optional.  The subject alternative names. (e.g. "shopping.example.com", "mail.example.com").</param>
        /// <param name="organizationalUnit">The organizational unit (e.g. "Engineering Dept").</param>
        /// <param name="organization">The organization (e.g. "The Example Company").</param>
        /// <param name="locality">The locality (e.g. "Seattle").</param>
        /// <param name="state">The state (e.g. "Washington").</param>
        /// <param name="country">The country (e.g. "US").</param>
        /// <param name="signatureAlgorithm">OPTIONAL signature algorithm to use.  DEFAULT is SHA1 with RSA.</param>
        /// <returns>
        /// The certificate signing request.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="asymmetricKeyPair"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="commonName"/> or <paramref name="organizationalUnit"/>or <paramref name="organization"/> or <paramref name="locality"/> or <paramref name="state"/> or <paramref name="country"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="commonName"/> or <paramref name="organizationalUnit"/> or <paramref name="organization"/> or <paramref name="locality"/> or <paramref name="state"/> or <paramref name="country"/> is white space.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "There are many types required to construct a CSR.")]
        public static Pkcs10CertificationRequest CreateSslCsr(
            this AsymmetricCipherKeyPair asymmetricKeyPair,
            string commonName,
            IReadOnlyCollection<string> subjectAlternativeNames,
            string organizationalUnit,
            string organization,
            string locality,
            string state,
            string country,
            SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.Sha1WithRsaEncryption)
        {
            var sslCreationInfo = GetSslCreationInfo(asymmetricKeyPair, commonName, subjectAlternativeNames, organizationalUnit, organization, locality, state, country, signatureAlgorithm);

            var extensionsForCsr = sslCreationInfo.OidToExtensionMap.ToDictionary(_ => _.Key, _ => _.Value);

            var result = new Pkcs10CertificationRequest(
                sslCreationInfo.SignatureFactory,
                sslCreationInfo.Subject,
                asymmetricKeyPair.Public,
                new DerSet(new AttributePkcs(PkcsObjectIdentifiers.Pkcs9AtExtensionRequest, new DerSet(new X509Extensions(extensionsForCsr)))));

            return result;
        }

        /// <summary>
        /// Creates a self-signed SSL certificate.
        /// </summary>
        /// <param name="asymmetricKeyPair">The asymmetric cipher key pair.</param>
        /// <param name="commonName">The common name (e.g. "example.com").</param>
        /// <param name="subjectAlternativeNames">Optional.  The subject alternative names. (e.g. "shopping.example.com", "mail.example.com").</param>
        /// <param name="organizationalUnit">The organizational unit (e.g. "Engineering Dept").</param>
        /// <param name="organization">The organization (e.g. "The Example Company").</param>
        /// <param name="locality">The locality (e.g. "Seattle").</param>
        /// <param name="state">The state (e.g. "Washington").</param>
        /// <param name="country">The country (e.g. "US").</param>
        /// <param name="validityTimeRange">The validity time range.</param>
        /// <param name="signatureAlgorithm">OPTIONAL signature algorithm to use.  DEFAULT is SHA1 with RSA.</param>
        /// <returns>
        /// The certificate.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="asymmetricKeyPair"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="commonName"/> or <paramref name="organizationalUnit"/>or <paramref name="organization"/> or <paramref name="locality"/> or <paramref name="state"/> or <paramref name="country"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="commonName"/> or <paramref name="organizationalUnit"/> or <paramref name="organization"/> or <paramref name="locality"/> or <paramref name="state"/> or <paramref name="country"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="validityTimeRange"/> is null.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "There are many types required to construct a CSR.")]
        public static X509Certificate2 CreateSelfSignedSslCertificate(
            this AsymmetricCipherKeyPair asymmetricKeyPair,
            string commonName,
            IReadOnlyCollection<string> subjectAlternativeNames,
            string organizationalUnit,
            string organization,
            string locality,
            string state,
            string country,
            UtcDateTimeRangeInclusive validityTimeRange,
            SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.Sha1WithRsaEncryption)
        {
            var sslCreationInfo = GetSslCreationInfo(asymmetricKeyPair, commonName, subjectAlternativeNames, organizationalUnit, organization, locality, state, country, signatureAlgorithm);

            if (validityTimeRange == null)
            {
                throw new ArgumentNullException(nameof(validityTimeRange));
            }

            var generator = new X509V3CertificateGenerator();

            foreach (var extensionIdentifier in sslCreationInfo.OidToExtensionMap.Keys)
            {
                var extension = sslCreationInfo.OidToExtensionMap[extensionIdentifier];

                generator.AddExtension(extensionIdentifier, extension.IsCritical, extension.GetParsedValue());
            }

            generator.AddExtension(X509Extensions.AuthorityKeyIdentifier, false, new AuthorityKeyIdentifierStructure(asymmetricKeyPair.Public));

            generator.SetSubjectDN(sslCreationInfo.Subject);

            generator.SetPublicKey(asymmetricKeyPair.Public);

            generator.SetIssuerDN(sslCreationInfo.Subject);

            generator.SetNotBefore(validityTimeRange.StartDateTimeInUtc);

            generator.SetNotAfter(validityTimeRange.EndDateTimeInUtc);

            generator.SetSerialNumber(new BigInteger(DateTime.UtcNow.Ticks.ToString(CultureInfo.InvariantCulture)));

            var bouncyCert = generator.Generate(sslCreationInfo.SignatureFactory);

            var result = bouncyCert.ToSystemX509Certificate();

            return result;
        }

        /// <summary>
        /// Creates a PKCS #12 certificate (bundles private key with X.509 certificate).
        /// </summary>
        /// <param name="privateKey">The private key.</param>
        /// <param name="cert">The certificate.</param>
        /// <returns>
        /// The certificate.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="privateKey"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="privateKey"/> is not private.</exception>
        /// <exception cref="NotSupportedException">The specified kind of private key is not supported.</exception>
        public static X509Certificate2 CreatePkcs12Certificate(
            this X509Certificate2 cert,
            AsymmetricKeyParameter privateKey)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            if (privateKey == null)
            {
                throw new ArgumentNullException(nameof(privateKey));
            }

            if (!privateKey.IsPrivate)
            {
                throw new ArgumentException(Invariant($"'{nameof(privateKey.IsPrivate)}' is false"));
            }
            
            if (privateKey is RsaPrivateCrtKeyParameters rsaPrivateKey)
            {
                cert.PrivateKey = DotNetUtilities.ToRSA(rsaPrivateKey);
            }
            else
            {
                throw new NotSupportedException(Invariant($"This type of {nameof(AsymmetricKeyParameter)} is not supported: {privateKey.GetType()}."));
            }

            // Mark private key as exportable so that code using this cert has access to it.
            // To do so, need to set an empty string password.
            var result = new X509Certificate2(cert.Export(X509ContentType.Pkcs12), string.Empty, X509KeyStorageFlags.Exportable);

            return result;
        }

        /// <summary>
        /// Decrypts a string that was encrypted as a base-64 string.
        /// </summary>
        /// <param name="base64EncodedEncryptedBytes">The base-64 encoded encrypted bytes.</param>
        /// <param name="certificate">The certificate that was used for encryption.</param>
        /// <param name="encoding">Optional encoding to use.  Default is to use UTF-8.</param>
        /// <returns>
        /// The decrypted string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="base64EncodedEncryptedBytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        public static string DecryptStringFromBase64String(
            this string base64EncodedEncryptedBytes,
            X509Certificate2 certificate,
            Encoding encoding = null)
        {
            if (base64EncodedEncryptedBytes == null)
            {
                throw new ArgumentNullException(nameof(base64EncodedEncryptedBytes));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            var result = base64EncodedEncryptedBytes.DecryptStringFromBase64String(new[] { certificate }, encoding);

            return result;
        }

        /// <summary>
        /// Decrypts a string that was encrypted as a base-64 string.
        /// </summary>
        /// <param name="base64EncodedEncryptedBytes">The encrypted text to be decrypted.</param>
        /// <param name="certificates">A set of certificates containing the one that was used for encryption.</param>
        /// <param name="encoding">Optional encoding to use.  Default is to use UTF-8.</param>
        /// <returns>
        /// The decrypted string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="base64EncodedEncryptedBytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificates"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certificates"/> is empty or contains a null element.</exception>
        public static string DecryptStringFromBase64String(
            this string base64EncodedEncryptedBytes,
            IReadOnlyCollection<X509Certificate2> certificates,
            Encoding encoding = null)
        {
            if (base64EncodedEncryptedBytes == null)
            {
                throw new ArgumentNullException(nameof(base64EncodedEncryptedBytes));
            }

            if (certificates == null)
            {
                throw new ArgumentNullException(nameof(certificates));
            }

            if (!certificates.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' is an empty enumerable"));
            }

            if (certificates.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' contains an element that is null"));
            }

            encoding = encoding ?? Encoding.UTF8;

            var decryptedBytes = base64EncodedEncryptedBytes.DecryptByteArrayFromBase64String(certificates);

            var result = encoding.GetString(decryptedBytes);

            return result;
        }

        /// <summary>
        /// Decrypts a byte array from a base-64 string.
        /// </summary>
        /// <param name="base64EncodedEncryptedBytes">The base-64 encoded encrypted bytes.</param>
        /// <param name="certificate">The certificate that was used for encryption.</param>
        /// <returns>
        /// The decrypted bytes.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="base64EncodedEncryptedBytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        public static byte[] DecryptByteArrayFromBase64String(
            this string base64EncodedEncryptedBytes,
            X509Certificate2 certificate)
        {
            if (base64EncodedEncryptedBytes == null)
            {
                throw new ArgumentNullException(nameof(base64EncodedEncryptedBytes));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            var result = base64EncodedEncryptedBytes.DecryptByteArrayFromBase64String(new[] { certificate });

            return result;
        }

        /// <summary>
        /// Decrypts a byte array from a base-64 string.
        /// </summary>
        /// <param name="base64EncodedEncryptedBytes">The base-64 encoded encrypted bytes.</param>
        /// <param name="certificates">A set of certificates containing the one that was used for encryption.</param>
        /// <returns>
        /// The decrypted bytes.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="base64EncodedEncryptedBytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificates"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certificates"/> is empty or contains a null element.</exception>
        public static byte[] DecryptByteArrayFromBase64String(
            this string base64EncodedEncryptedBytes,
            IReadOnlyCollection<X509Certificate2> certificates)
        {
            if (base64EncodedEncryptedBytes == null)
            {
                throw new ArgumentNullException(nameof(base64EncodedEncryptedBytes));
            }

            if (certificates == null)
            {
                throw new ArgumentNullException(nameof(certificates));
            }

            if (!certificates.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' is an empty enumerable"));
            }

            if (certificates.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' contains an element that is null"));
            }

            var encryptedBytes = Convert.FromBase64String(base64EncodedEncryptedBytes);

            var result = encryptedBytes.Decrypt(certificates);

            return result;
        }

        /// <summary>
        /// Decrypts a byte array.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <param name="certificate">The certificate that was used for encryption.</param>
        /// <returns>
        /// The decrypted string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="bytes"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="bytes"/> is empty.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "bytes", Justification = ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity)]
        public static byte[] Decrypt(
            this byte[] bytes,
            X509Certificate2 certificate)
        {
            var result = bytes.Decrypt(new[] { certificate });

            return result;
        }

        /// <summary>
        /// Decrypts a byte array.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <param name="certificates">A set of certificates containing the one that was used for encryption.</param>
        /// <returns>
        /// The decrypted string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="bytes"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="bytes"/> is empty.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificates"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certificates"/> is empty or contains a null element.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "bytes", Justification = ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity)]
        public static byte[] Decrypt(
            this byte[] bytes,
            IReadOnlyCollection<X509Certificate2> certificates)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            if (bytes.Length == 0)
            {
                throw new ArgumentException(Invariant($"{nameof(bytes)} is empty."));
            }

            if (certificates == null)
            {
                throw new ArgumentNullException(nameof(certificates));
            }

            if (!certificates.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' is an empty enumerable"));
            }

            if (certificates.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' contains an element that is null"));
            }

            byte[] result;

            try
            {
                // NOTE: This approach doesn't work for large payloads.
                var certCollection = new X509Certificate2Collection(certificates.ToArray());

                var envelopedCms = new EnvelopedCms();

                envelopedCms.Decode(bytes);

                envelopedCms.Decrypt(certCollection);

                result = envelopedCms.ContentInfo.Content;
            }
            catch (CryptographicException ex) when (ex.Message.Contains("ASN1 value too large"))
            {
                // NOTE: Use this approach for large payloads, except that it won't work for certificates
                // that originate in the Certificate Store unless those certificates are marked exportable.
                // Further, it doesn't work with a collection of certificates; a single certificate is required.
                var certificate = certificates.SingleOrDefault();

                if (certificate == null)
                {
                    throw new NotSupportedException("Multiple certificates in the chain is not supported.");
                }

                var cmsEnvelopedData = new CmsEnvelopedData(bytes);

                var recipient = cmsEnvelopedData
                    .GetRecipientInfos()
                    .GetRecipients()
                    .Cast<KeyTransRecipientInformation>()
                    .Single();

                var privateKey = certificate.PrivateKey;

                ICipherParameters cipherParameters;

                if (privateKey is RSACryptoServiceProvider rsaProvider)
                {
                    var parameters = rsaProvider.ExportParameters(true);

                    cipherParameters = new RsaPrivateCrtKeyParameters(
                        new BigInteger(1, parameters.Modulus),
                        new BigInteger(1, parameters.Exponent),
                        new BigInteger(1, parameters.D),
                        new BigInteger(1, parameters.P),
                        new BigInteger(1, parameters.Q),
                        new BigInteger(1, parameters.DP),
                        new BigInteger(1, parameters.DQ),
                        new BigInteger(1, parameters.InverseQ));
                }
                else
                {
                    throw new NotSupportedException(Invariant($"This kind of private key is not supported: {privateKey.SignatureAlgorithm}."));
                }

                result = recipient.GetContent(cipherParameters);
            }

            return result;
        }

        /// <summary>
        /// Encrypts the specified string to a base-64 string.
        /// </summary>
        /// <param name="plaintext">The plaintext to be encrypted.</param>
        /// <param name="certificate">The certificate to use for encryption.</param>
        /// <param name="encoding">Optional encoding to use.  Default is to use UTF-8.</param>
        /// <returns>
        /// The specified string encrypted as a base-64 string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="plaintext"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        public static string EncryptToBase64String(
            this string plaintext,
            X509Certificate2 certificate,
            Encoding encoding = null)
        {
            if (plaintext == null)
            {
                throw new ArgumentNullException(nameof(plaintext));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            encoding = encoding ?? Encoding.UTF8;

            var bytes = encoding.GetBytes(plaintext);

            var result = bytes.EncryptToBase64String(certificate);

            return result;
        }

        /// <summary>
        /// Encrypts the specified byte array to a base-64 string.
        /// </summary>
        /// <param name="bytes">The bytes to be encrypted.</param>
        /// <param name="certificate">The certificate to use for encryption.</param>
        /// <returns>
        /// The specified byte array encrypted as a base-64 string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="bytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "bytes", Justification = ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity)]
        public static string EncryptToBase64String(
            this byte[] bytes,
            X509Certificate2 certificate)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            var encryptedBytes = bytes.Encrypt(certificate);

            var result = Convert.ToBase64String(encryptedBytes);

            return result;
        }

        /// <summary>
        /// Encrypts the specified bytes.
        /// </summary>
        /// <param name="bytes">The bytes to encrypt.</param>
        /// <param name="certificate">The certificate to use for encryption.</param>
        /// <returns>
        /// The encrypted bytes.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="bytes"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="bytes"/> is empty.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "bytes", Justification = ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity)]
        public static byte[] Encrypt(
            this byte[] bytes,
            X509Certificate2 certificate)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            if (bytes.Length == 0)
            {
                throw new ArgumentException(Invariant($"{nameof(bytes)} is empty."));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            var contentInfo = new ContentInfo(bytes);

            var envelopedCms = new EnvelopedCms(contentInfo);

            var cmsRecipient = new CmsRecipient(certificate);

            envelopedCms.Encrypt(cmsRecipient);

            var result = envelopedCms.Encode();

            return result;
        }

        /// <summary>
        /// Gets a certificate collection from the certificate store.
        /// </summary>
        /// <param name="storeLocation">The store location.</param>
        /// <param name="storeName">The name of the store.</param>
        /// <returns>
        /// A certificate collection.
        /// </returns>
        public static X509Certificate2Collection GetCertificateCollectionFromStore(
            StoreLocation storeLocation,
            StoreName storeName)
        {
            using (var store = new X509Store(storeName, storeLocation))
            {
                store.Open(OpenFlags.ReadOnly);

                var result = store.Certificates;

                return result;
            }
        }

        /// <summary>
        /// Gets certificates from the certificate store.
        /// </summary>
        /// <param name="storeLocation">The store location.</param>
        /// <param name="storeName">The name of the store.</param>
        /// <returns>
        /// Certificates from the certificate store.
        /// </returns>
        public static IReadOnlyCollection<X509Certificate2> GetCertificatesFromStore(
            StoreLocation storeLocation,
            StoreName storeName)
        {
            var certificateCollection = GetCertificateCollectionFromStore(storeLocation, storeName);

            var result = certificateCollection.OfType<X509Certificate2>().ToList();

            return result;
        }

        /// <summary>
        /// Finds a certificate in the specified store.
        /// </summary>
        /// <param name="storeLocation">Store location (eg. LocalMachine).</param>
        /// <param name="storeName">Store name to search for certificate (eg: My).</param>
        /// <param name="thumbprint">Thumbprint of the certificate to search for.</param>
        /// <param name="shouldThrowIfNotFound">A value indicating whether to throw an exception if the certificate is not found.</param>
        /// <param name="shouldThrowIfCertificateIsInvalid">A value indicating whether to throw an exception if the certificate is not valid.</param>
        /// <returns>
        /// The certificate if found, otherwise null.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="thumbprint"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="thumbprint"/> is white space.</exception>
        /// <exception cref="InvalidOperationException">The certificate was not found and <paramref name="shouldThrowIfNotFound"/> is true.</exception>
        /// <exception cref="InvalidOperationException">Found multiple certificates.</exception>
        /// <exception cref="InvalidOperationException">The certificate is invalid and <paramref name="shouldThrowIfCertificateIsInvalid"/> is true.</exception>
        public static X509Certificate2 GetCertificateFromStore(
            this StoreLocation storeLocation,
            StoreName storeName,
            string thumbprint,
            bool shouldThrowIfNotFound,
            bool shouldThrowIfCertificateIsInvalid)
        {
            var certificateCollection = GetCertificateCollectionFromStore(storeLocation, storeName);

            var potentiallyInvalidCerts = certificateCollection.Find(X509FindType.FindByThumbprint, thumbprint, false);

            if (potentiallyInvalidCerts.Count == 0)
            {
                if (shouldThrowIfNotFound)
                {
                    throw new InvalidOperationException(Invariant($"Certificate was not found.  Specified thumbprint: {thumbprint}"));
                }
                else
                {
                    return null;
                }
            }

            if (potentiallyInvalidCerts.Count != 1)
            {
                throw new InvalidOperationException(Invariant($"Expected a single certificate but found {potentiallyInvalidCerts.Count} certificates.  Specified thumbprint: {thumbprint}"));
            }

            if (shouldThrowIfCertificateIsInvalid)
            {
                var validCerts = certificateCollection.Find(X509FindType.FindByThumbprint, thumbprint, true);

                if (validCerts.Count != 1)
                {
                    throw new InvalidOperationException(Invariant($"The certificate is invalid and {nameof(shouldThrowIfCertificateIsInvalid)} is true.  Specified thumbprint: {thumbprint}"));
                }
            }

            var result = potentiallyInvalidCerts[0];

            return result;
        }

        /// <summary>
        /// Extracts the cryptographic objects contained in a PFX file.
        /// </summary>
        /// <param name="input">A byte array of the PFX.</param>
        /// <param name="clearTextPassword">The PFX password in clear-text.</param>
        /// <returns>
        /// The cryptographic objects contained in the specified PFX file.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        public static ExtractedPfxFile ExtractCryptographicObjectsFromPfxFile(
            byte[] input,
            string clearTextPassword)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            using (var inputStream = new MemoryStream(input))
            {
                var result = ExtractCryptographicObjectsFromPfxFile(inputStream, clearTextPassword);

                return result;
            }
        }

        /// <summary>
        /// Extracts the cryptographic objects contained in a PFX file.
        /// </summary>
        /// <param name="input">A stream with the PFX.</param>
        /// <param name="clearTextPassword">The PFX password in clear-text.</param>
        /// <returns>
        /// The cryptographic objects contained in the specified PFX file.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="input"/> is not readable.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        public static ExtractedPfxFile ExtractCryptographicObjectsFromPfxFile(
            Stream input,
            string clearTextPassword)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }

            if (!input.CanRead)
            {
                throw new ArgumentException(Invariant($"'{nameof(input.CanRead)}' is false"));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            var store = new Pkcs12Store(input, clearTextPassword.ToCharArray());
            
            var aliases = store.Aliases;

            var certificateChain = new List<X509Certificate2>();
            
            foreach (var alias in aliases)
            {
                var certEntry = store.GetCertificate(alias.ToString());

                certificateChain.Add(certEntry.Certificate.ToSystemX509Certificate());
            }

            var endUserCertificate = certificateChain.GetEndUserCertFromCertChain();

            var subjectAttributes = endUserCertificate.GetX509SubjectAttributes();

            var storeKey = store.GetKey(subjectAttributes[X509SubjectAttributeKind.CommonName]);

            var privateKey = storeKey.Key;

            var result = new ExtractedPfxFile(certificateChain, privateKey);

            return result;
        }

        /// <summary>
        /// Finds a certificate in the specified store.
        /// </summary>
        /// <param name="storeLocation">Store location (eg. LocalMachine).</param>
        /// <param name="storeName">Store name to search for certificate (eg: My).</param>
        /// <param name="thumbprint">Thumbprint of the certificate to search for.</param>
        /// <param name="unsecuredPassword">Password to use for PFX file.</param>
        /// <param name="filePath">PFX file path to write to.</param>
        /// <param name="shouldThrowIfCertificateIsInvalid">A value indicating whether to throw an exception if the certificate is not valid.</param>
        /// <param name="shouldThrowIfPrivateKeyIsMissing">A value indicating whether to throw an exception if the certificate does not contain a private key.</param>
        /// <exception cref="ArgumentNullException"><paramref name="thumbprint"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="thumbprint"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="unsecuredPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="unsecuredPassword"/> is white space.</exception>
        /// <exception cref="InvalidOperationException">The certificate was not found.</exception>
        /// <exception cref="InvalidOperationException">Found multiple certificates.</exception>
        /// <exception cref="InvalidOperationException">The certificate is invalid and <paramref name="shouldThrowIfCertificateIsInvalid"/> is true.</exception>
        /// <exception cref="InvalidOperationException">The certificate does not contain the private key and <paramref name="shouldThrowIfPrivateKeyIsMissing"/> is true.</exception>
        public static void ExportPfxFromCertificateStoreToFile(
            this StoreLocation storeLocation,
            StoreName storeName,
            string thumbprint,
            string unsecuredPassword,
            string filePath,
            bool shouldThrowIfCertificateIsInvalid,
            bool shouldThrowIfPrivateKeyIsMissing)
        {
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            if (string.IsNullOrWhiteSpace(thumbprint))
            {
                throw new ArgumentException(Invariant($"'{nameof(thumbprint)}' is white space"));
            }

            if (unsecuredPassword == null)
            {
                throw new ArgumentNullException(nameof(unsecuredPassword));
            }

            if (string.IsNullOrWhiteSpace(unsecuredPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(unsecuredPassword)}' is white space"));
            }

            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            if (string.IsNullOrWhiteSpace(filePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(filePath)}' is white space"));
            }

            var cert = GetCertificateFromStore(storeLocation, storeName, thumbprint, true, shouldThrowIfCertificateIsInvalid);

            if (shouldThrowIfPrivateKeyIsMissing && (!cert.HasPrivateKey))
            {
                throw new InvalidOperationException(Invariant($"The certificate does not contain the private key and {nameof(shouldThrowIfPrivateKeyIsMissing)} is true.  Specified thumbprint: {thumbprint}"));
            }

            AsymmetricKeyParameter privateKey = null;

            if (cert.HasPrivateKey)
            {
                try
                {
                    var rsa = (RSACryptoServiceProvider)cert.PrivateKey;

                    var keyPair = DotNetUtilities.GetRsaKeyPair(rsa);

                    privateKey = keyPair.Private;
                }
                catch (CryptographicException)
                {
                    // 1. we have seen cases where cert.PrivateKey throws on a cert that was NOT created using CertHelper
                    // 2. we have seen cases where .GetRsaKeyPair(rsa) throws on a cert that was installed via a PFX file created by CertHelper (NOT marking the private key as exportable)
                }
            }

            var parser = new X509CertificateParser();

            var certs = new List<X509Certificate2>();

            using (var chain = new X509Chain())
            {
                chain.Build(cert);

                foreach (var chainElement in chain.ChainElements)
                {
                    var bouncyCert = parser.ReadCertificate(chainElement.Certificate.Export(X509ContentType.Cert));

                    certs.Add(bouncyCert.ToSystemX509Certificate());
                }
            }

            CreatePfxFile(certs, unsecuredPassword, filePath, true, privateKey);
        }

        /// <summary>
        /// Gets the end-user certificate in a certificate chain.
        /// </summary>
        /// <param name="certChain">The certificate chain.</param>
        /// <returns>
        /// The end-user certificate in the specified certificate chain.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is malformed.</exception>
        public static X509Certificate2 GetEndUserCertFromCertChain(
            this IReadOnlyCollection<X509Certificate2> certChain)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            var result = certChain.OrderCertChainFromHighestToLowestLevelOfTrust().Last();

            return result;
        }

        /// <summary>
        /// Gets the intermediate certificate chain from a certificate chain that contains
        /// the end-user certificate.
        /// </summary>
        /// <param name="certChain">The certificate chain.</param>
        /// <returns>
        /// The intermediate cert chain.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is malformed.</exception>
        public static IReadOnlyList<X509Certificate2> GetIntermediateChainFromCertChain(
            this IReadOnlyCollection<X509Certificate2> certChain)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            var result = certChain.OrderCertChainFromHighestToLowestLevelOfTrust().Take(certChain.Count - 1).ToList();

            return result;
        }

        /// <summary>
        /// Gets the thumbprint of an X509 certificate.
        /// </summary>
        /// <param name="cert">The certificate.</param>
        /// <returns>
        /// The thumbprint of the specified X509 certificate.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "We specifically want lower-case here.")]
        public static string GetThumbprint(
            this X509Certificate2 cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            using (var shaProvider = new SHA1CryptoServiceProvider())
            {
                var hash = shaProvider.ComputeHash(cert.ToBouncyX509Certificate().GetEncoded());

                var result = BitConverter.ToString(hash).Replace("-", " ").ToLowerInvariant();

                return result;
            }
        }

        /// <summary>
        /// Gets the range of time over which a certificate is valid.
        /// </summary>
        /// <param name="cert">The certificate.</param>
        /// <returns>
        /// The range of time over which the specified certificate is valid.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        public static UtcDateTimeRangeInclusive GetValidityPeriod(
            this X509Certificate2 cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            var bouncyCert = cert.ToBouncyX509Certificate();

            var result = new UtcDateTimeRangeInclusive(bouncyCert.NotBefore, bouncyCert.NotAfter);

            return result;
        }

        /// <summary>
        /// Gets the X509 field values from a certificate.
        /// </summary>
        /// <param name="cert">The certificate.</param>
        /// <returns>
        /// The X509 field values indexed by the kind of field.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        public static IReadOnlyDictionary<X509FieldKind, string> GetX509Fields(
            this X509Certificate2 cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            var bouncyCert = cert.ToBouncyX509Certificate();

            var result = new Dictionary<X509FieldKind, string>
            {
                { X509FieldKind.IssuerName, bouncyCert.IssuerDN?.ToString() },
                { X509FieldKind.NotAfter, bouncyCert.NotAfter.ToString("yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture) },
                { X509FieldKind.NotBefore, bouncyCert.NotBefore.ToString("yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture) },
                { X509FieldKind.SerialNumber, bouncyCert.SerialNumber?.ToString() },
                { X509FieldKind.SignatureAlgorithmName, bouncyCert.SigAlgName },
                { X509FieldKind.SubjectName, bouncyCert.SubjectDN?.ToString() },
                { X509FieldKind.Version, bouncyCert.Version.ToString(CultureInfo.InvariantCulture) },
            };
            return result;
        }

        /// <summary>
        /// Gets the X509 subject attribute values from a certificate signing request.
        /// </summary>
        /// <param name="csr">The certificate signing request.</param>
        /// <returns>
        /// The X509 subject attribute values indexed by the kind of subject attribute.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="csr"/> is null.</exception>
        [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "Specifically supporting this kind of CSR.")]
        public static IReadOnlyDictionary<X509SubjectAttributeKind, string> GetX509SubjectAttributes(
            this Pkcs10CertificationRequest csr)
        {
            if (csr == null)
            {
                throw new ArgumentNullException(nameof(csr));
            }

            var subject = csr.GetCertificationRequestInfo().Subject;

            var result = subject.GetX509SubjectAttributes();

            return result;
        }

        /// <summary>
        /// Gets the X509 subject attribute values from a certificate.
        /// </summary>
        /// <param name="cert">The certificate.</param>
        /// <returns>
        /// The X509 subject attribute values indexed by the kind of subject attribute.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        public static IReadOnlyDictionary<X509SubjectAttributeKind, string> GetX509SubjectAttributes(
            this X509Certificate2 cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            var bouncyCert = cert.ToBouncyX509Certificate();

            var subject = bouncyCert.SubjectDN;

            var result = subject.GetX509SubjectAttributes();

            return result;
        }

        /// <summary>
        /// Gets the X509 subject attribute values from a subject.
        /// </summary>
        /// <param name="subject">The subject.</param>
        /// <returns>
        /// The X509 subject attribute values indexed by the kind of subject attribute.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="subject"/> is null.</exception>
        public static IReadOnlyDictionary<X509SubjectAttributeKind, string> GetX509SubjectAttributes(
            this X509Name subject)
        {
            if (subject == null)
            {
                throw new ArgumentNullException(nameof(subject));
            }

            var objectIds = subject.GetOidList();
            var values = subject.GetValueList();

            var result = new Dictionary<X509SubjectAttributeKind, string>();

            for (int x = 0; x < objectIds.Count; x++)
            {
                if ((objectIds[x] is DerObjectIdentifier derId) && (values[x] is string value))
                {
                    if (derId.Id == X509Name.C.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Country, value);
                    }
                    else if (derId.Id == X509Name.O.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Organization, value);
                    }
                    else if (derId.Id == X509Name.OU.Id)
                    {
                        result.Add(X509SubjectAttributeKind.OrganizationalUnit, value);
                    }
                    else if (derId.Id == X509Name.T.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Title, value);
                    }
                    else if (derId.Id == X509Name.CN.Id)
                    {
                        result.Add(X509SubjectAttributeKind.CommonName, value);
                    }
                    else if (derId.Id == X509Name.Street.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Street, value);
                    }
                    else if (derId.Id == X509Name.SerialNumber.Id)
                    {
                        result.Add(X509SubjectAttributeKind.SerialNumber, value);
                    }
                    else if (derId.Id == X509Name.L.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Locality, value);
                    }
                    else if (derId.Id == X509Name.ST.Id)
                    {
                        result.Add(X509SubjectAttributeKind.State, value);
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Re-orders a certificate chain from lowest to highest level of trust.
        /// </summary>
        /// <param name="certChain">The certificate chain to re-order.</param>
        /// <returns>
        /// The certificates in the specified chain, ordered from lowest to highest level of trust.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is malformed.</exception>
        public static IReadOnlyList<X509Certificate2> OrderCertChainFromLowestToHighestLevelOfTrust(
            this IReadOnlyCollection<X509Certificate2> certChain)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            var result = certChain.OrderCertChainFromHighestToLowestLevelOfTrust().Reverse().ToList();

            return result;
        }

        /// <summary>
        /// Re-orders a certificate chain from highest to lowest level of trust.
        /// </summary>
        /// <param name="certChain">The certificate chain to re-order.</param>
        /// <returns>
        /// The certificates in the specified chain, ordered from highest to lowest level of trust.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is malformed.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = ObcSuppressBecause.CA1502_AvoidExcessiveComplexity_DisagreeWithAssessment)]
        public static IReadOnlyList<X509Certificate2> OrderCertChainFromHighestToLowestLevelOfTrust(
            this IReadOnlyCollection<X509Certificate2> certChain)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            certChain = certChain.Distinct().ToList();

            var bouncyCertChain = certChain
                .Select(_ => _.ToBouncyX509Certificate())
                .Distinct()
                .ToList();

            // for every cert, record which other certs verify it
            var parentCertsByChildCert = new Dictionary<X509Certificate, List<X509Certificate>>();
            foreach (var bouncyCert in bouncyCertChain)
            {
                parentCertsByChildCert.Add(bouncyCert, new List<X509Certificate>());

                var otherCerts = bouncyCertChain.Except(new[] { bouncyCert }).ToList();

                foreach (var otherCert in otherCerts)
                {
                    try
                    {
                        bouncyCert.Verify(otherCert.GetPublicKey());

                        parentCertsByChildCert[bouncyCert].Add(otherCert);
                    }

                    // ReSharper disable once EmptyGeneralCatchClause
                    catch (Exception)
                    {
                    }
                }
            }

            // any cert has two parents?
            if (parentCertsByChildCert.Values.Any(_ => _.Count > 1))
            {
                throw new ArgumentException("the cert chain is malformed");
            }

            // should only be one cert with no parent
            if (parentCertsByChildCert.Values.Count(_ => !_.Any()) != 1)
            {
                throw new ArgumentException("the cert chain is malformed");
            }

            // identify and remove the root cert, the remaining certs should have only one parent
            var rootCert = parentCertsByChildCert.Single(_ => !_.Value.Any()).Key;
            parentCertsByChildCert.Remove(rootCert);

            // no two certs should have the same parent
            if (parentCertsByChildCert.SelectMany(_ => _.Value).Distinct().Count() != parentCertsByChildCert.Count)
            {
                throw new ArgumentException("the cert chain is malformed");
            }

            // flip it and index the certs by parent
            var childCertByParentCert = parentCertsByChildCert.ToDictionary(_ => _.Value.Single(), _ => _.Key);
            var bouncyResult = new List<X509Certificate> { rootCert };
            while (childCertByParentCert.ContainsKey(bouncyResult.Last()))
            {
                bouncyResult.Add(childCertByParentCert[bouncyResult.Last()]);
            }

            var result = bouncyResult
                .Select(_ => _.ToSystemX509Certificate())
                .ToList();

            return result;
        }

        /// <summary>
        /// Extracts a certificate chain from PKCS#7 CMS payload encoded in PEM.
        /// </summary>
        /// <param name="pemEncodedPkcs7">The payload containing the PKCS#7 CMS data.</param>
        /// <remarks>
        /// The method is expecting a PKCS#7/CMS SignedData structure containing no "content" and zero SignerInfos.
        /// </remarks>
        /// <returns>
        /// The certificate chain contained in the specified payload.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedPkcs7"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedPkcs7"/> is white space.</exception>
        public static IReadOnlyList<X509Certificate2> ReadCertChainFromPemEncodedPkcs7CmsString(
            string pemEncodedPkcs7)
        {
            if (pemEncodedPkcs7 == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedPkcs7));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedPkcs7))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedPkcs7)}' is white space"));
            }

            IReadOnlyList<X509Certificate2> result;
            using (var stringReader = new StringReader(pemEncodedPkcs7))
            {
                var pemReader = new PemReader(stringReader);

                var pemObject = pemReader.ReadPemObject();
                
                var data = new CmsSignedData(pemObject.Content);
                
                var certStore = data.GetCertificates("COLLECTION");
                
                result = certStore
                    .GetMatches(null)
                    .Cast<X509Certificate>()
                    .Select(_ => _.ToSystemX509Certificate())
                    .ToList();
            }

            return result;
        }

        /// <summary>
        /// Reads one or more certs encoded in PEM.
        /// </summary>
        /// <param name="pemEncodedCerts">The PEM encoded certificates.</param>
        /// <returns>
        /// The certificates.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedCerts"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedCerts"/> is white space.</exception>
        public static IReadOnlyList<X509Certificate2> ReadCertsFromPemEncodedString(
            string pemEncodedCerts)
        {
            if (pemEncodedCerts == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedCerts));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedCerts))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedCerts)}' is white space"));
            }

            // remove empty lines - required so that PemReader.ReadObject doesn't return null in-between returning certs
            pemEncodedCerts = Regex.Replace(pemEncodedCerts, @"^\s*$[\r\n]*", string.Empty, RegexOptions.Multiline);

            var result = new List<X509Certificate2>();
            using (var stringReader = new StringReader(pemEncodedCerts))
            {
                var pemReader = new PemReader(stringReader);

                var certObject = pemReader.ReadObject();
                
                while (certObject != null)
                {
                    var cert = certObject as X509Certificate;

                    result.Add(cert.ToSystemX509Certificate());

                    certObject = pemReader.ReadObject();
                }
            }

            return result;
        }

        /// <summary>
        /// Reads a PKCS #12 certificate (bundles private key with X.509 certificate) from PEM-encoded strings.
        /// </summary>
        /// <param name="pemEncodedCert">The PEM-encoded certificate.</param>
        /// <param name="pemEncodedPrivateKey">The PEM-encoded private key.</param>
        /// <returns>
        /// The certificate.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedCert"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedCert"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedPrivateKey"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedPrivateKey"/> is white space.</exception>
        /// <exception cref="NotSupportedException">The specified kind of private key is not supported.</exception>
        public static X509Certificate2 ReadPkcs12CertFromPemEncodedStrings(
            string pemEncodedCert,
            string pemEncodedPrivateKey)
        {
            if (pemEncodedCert == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedCert));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedCert))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedCert)}' is white space"));
            }

            if (pemEncodedPrivateKey == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedPrivateKey));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedPrivateKey))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedPrivateKey)}' is white space"));
            }

            var cert = ReadCertsFromPemEncodedString(pemEncodedCert).Single();

            var privateKey = ReadPrivateKeyFromPemEncodedString(pemEncodedPrivateKey);

            var result = cert.CreatePkcs12Certificate(privateKey);

            return result;
        }

        /// <summary>
        /// Reads a certificate signing request encoded in PEM.
        /// </summary>
        /// <param name="pemEncodedCsr">The PEM encoded certificate signing request.</param>
        /// <returns>
        /// The certificate signing request.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedCsr"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedCsr"/> is white space.</exception>
        public static Pkcs10CertificationRequest ReadCsrFromPemEncodedString(
            string pemEncodedCsr)
        {
            if (pemEncodedCsr == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedCsr));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedCsr))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedCsr)}' is white space"));
            }

            Pkcs10CertificationRequest result;

            using (var stringReader = new StringReader(pemEncodedCsr))
            {
                var pemReader = new PemReader(stringReader);

                var pemObject = pemReader.ReadPemObject();

                result = new Pkcs10CertificationRequest(pemObject.Content);
            }

            return result;
        }

        /// <summary>
        /// Reads a private key encoded in PEM.
        /// </summary>
        /// <param name="pemEncodedPrivateKey">The PEM encoded private key.</param>
        /// <returns>
        /// The private key.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedPrivateKey"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedPrivateKey"/> is white space.</exception>
        public static AsymmetricKeyParameter ReadPrivateKeyFromPemEncodedString(
            string pemEncodedPrivateKey)
        {
            if (pemEncodedPrivateKey == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedPrivateKey));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedPrivateKey))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedPrivateKey)}' is white space"));
            }

            AsymmetricKeyParameter result;

            using (var stringReader = new StringReader(pemEncodedPrivateKey))
            {
                var pemReader = new PemReader(stringReader);

                var pemReaderResult = pemReader.ReadObject();

                if (pemReaderResult == null)
                {
                    result = null;
                }
                else if (pemReaderResult is RsaPrivateCrtKeyParameters rsaPrivateCrtKeyParameters)
                {
                    result = rsaPrivateCrtKeyParameters;
                }
                else if (pemReaderResult is AsymmetricCipherKeyPair asymmetricCipherKeyPair)
                {
                    result = asymmetricCipherKeyPair.Private;
                }
                else
                {
                    throw new NotSupportedException("Type of PEM encoded private key not supported: " + pemReaderResult.GetType());
                }
            }

            return result;
        }

        /// <summary>
        /// Converts a System certificate to a Bouncy certificate.
        /// </summary>
        /// <param name="cert">The System certificate.</param>
        /// <returns>
        /// The equivalent Bouncy certificate.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "Too confusing with System and Bouncy both having an X509Certificate type.")]
        public static X509Certificate ToBouncyX509Certificate(
            this X509Certificate2 cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            var result = DotNetUtilities.FromX509Certificate(cert);

            return result;
        }

        /// <summary>
        /// Converts a Bouncy certificate to a System certificate.
        /// </summary>
        /// <param name="cert">The Bouncy certificate.</param>
        /// <returns>
        /// The equivalent System certificate.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        public static X509Certificate2 ToSystemX509Certificate(
            this X509Certificate cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            var result = new X509Certificate2(cert.GetEncoded());

            return result;
        }

        private static SslCreationInfo GetSslCreationInfo(
            this AsymmetricCipherKeyPair asymmetricKeyPair,
            string commonName,
            IReadOnlyCollection<string> subjectAlternativeNames,
            string organizationalUnit,
            string organization,
            string locality,
            string state,
            string country,
            SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.Sha1WithRsaEncryption)
        {
            if (asymmetricKeyPair == null)
            {
                throw new ArgumentNullException(nameof(asymmetricKeyPair));
            }

            if (commonName == null)
            {
                throw new ArgumentNullException(nameof(commonName));
            }

            if (string.IsNullOrWhiteSpace(commonName))
            {
                throw new ArgumentException(Invariant($"'{nameof(commonName)}' is white space"));
            }

            if (organizationalUnit == null)
            {
                throw new ArgumentNullException(nameof(organizationalUnit));
            }

            if (string.IsNullOrWhiteSpace(organizationalUnit))
            {
                throw new ArgumentException(Invariant($"'{nameof(organizationalUnit)}' is white space"));
            }

            if (organization == null)
            {
                throw new ArgumentNullException(nameof(organization));
            }

            if (string.IsNullOrWhiteSpace(organization))
            {
                throw new ArgumentException(Invariant($"'{nameof(organization)}' is white space"));
            }

            if (locality == null)
            {
                throw new ArgumentNullException(nameof(locality));
            }

            if (string.IsNullOrWhiteSpace(locality))
            {
                throw new ArgumentException(Invariant($"'{nameof(locality)}' is white space"));
            }

            if (state == null)
            {
                throw new ArgumentNullException(nameof(state));
            }

            if (string.IsNullOrWhiteSpace(state))
            {
                throw new ArgumentException(Invariant($"'{nameof(state)}' is white space"));
            }

            if (country == null)
            {
                throw new ArgumentNullException(nameof(country));
            }

            if (string.IsNullOrWhiteSpace(country))
            {
                throw new ArgumentException(Invariant($"'{nameof(country)}' is white space"));
            }

            var attributesInOrder = new List<DerObjectValue>
            {
                new DerObjectValue(X509Name.C, country),
                new DerObjectValue(X509Name.ST, state),
                new DerObjectValue(X509Name.L, locality),
                new DerObjectValue(X509Name.O, organization),
                new DerObjectValue(X509Name.OU, organizationalUnit),
                new DerObjectValue(X509Name.CN, commonName),
            };

            var subject = new X509Name(attributesInOrder.Select(_ => _.Identifier).ToList(), attributesInOrder.Select(_ => _.Value).ToList());

            var oidToExtensionMap = new Dictionary<DerObjectIdentifier, X509Extension>
            {
                { X509Extensions.BasicConstraints, new X509Extension(true, new DerOctetString(new BasicConstraints(false))) },
                { X509Extensions.KeyUsage, new X509Extension(true, new DerOctetString(new KeyUsage(KeyUsage.DigitalSignature | KeyUsage.KeyEncipherment | KeyUsage.DataEncipherment | KeyUsage.NonRepudiation))) },
                { X509Extensions.ExtendedKeyUsage, new X509Extension(false, new DerOctetString(new ExtendedKeyUsage(KeyPurposeID.IdKPServerAuth, KeyPurposeID.IdKPClientAuth))) },
                { X509Extensions.SubjectKeyIdentifier, new X509Extension(false, new DerOctetString(new SubjectKeyIdentifierStructure(asymmetricKeyPair.Public))) },
            };

            if ((subjectAlternativeNames != null) && subjectAlternativeNames.Any())
            {
                var generalNames = subjectAlternativeNames.Select(_ => new GeneralName(GeneralName.DnsName, _)).ToArray();

                oidToExtensionMap.Add(X509Extensions.SubjectAlternativeName, new X509Extension(false, new DerOctetString(new GeneralNames(generalNames))));
            }

            var signatureFactory = new Asn1SignatureFactory(signatureAlgorithm.ToSignatureAlgorithmString(), asymmetricKeyPair.Private);

            var result = new SslCreationInfo
            {
                Subject = subject,
                SignatureFactory = signatureFactory,
                OidToExtensionMap = oidToExtensionMap,
            };

            return result;
        }

        private static string ToSignatureAlgorithmString(
            this SignatureAlgorithm signatureAlgorithm)
        {
            switch (signatureAlgorithm)
            {
                case SignatureAlgorithm.Md2WithRsaEncryption:
                    return "MD2WITHRSAENCRYPTION";
                case SignatureAlgorithm.Md5WithRsaEncryption:
                    return "MD5WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha1WithRsaEncryption:
                    return "SHA1WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha224WithRsaEncryption:
                    return "SHA224WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha256WithRsaEncryption:
                    return "SHA256WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha384WithRsaEncryption:
                    return "SHA384WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha512WithRsaEncryption:
                    return "SHA512WITHRSAENCRYPTION";
                case SignatureAlgorithm.IdRsassaPss:
                    return "SHA1WITHRSAANDMGF1";
                case SignatureAlgorithm.RsaSignatureWithRipeMd160:
                    return "RIPEMD160WITHRSAENCRYPTION";
                case SignatureAlgorithm.RsaSignatureWithRipeMd128:
                    return "RIPEMD128WITHRSAENCRYPTION";
                case SignatureAlgorithm.RsaSignatureWithRipeMd256:
                    return "RIPEMD256WITHRSAENCRYPTION";
                case SignatureAlgorithm.IdDsaWithSha1:
                    return "SHA1WITHDSA";
                case SignatureAlgorithm.DsaWithSha224:
                    return "SHA224WITHDSA";
                case SignatureAlgorithm.DsaWithSha256:
                    return "SHA256WITHDSA";
                case SignatureAlgorithm.DsaWithSha384:
                    return "SHA384WITHDSA";
                case SignatureAlgorithm.DsaWithSha512:
                    return "SHA512WITHDSA";
                case SignatureAlgorithm.EcDsaWithSha1:
                    return "SHA1WITHECDSA";
                case SignatureAlgorithm.EcDsaWithSha224:
                    return "SHA224WITHECDSA";
                case SignatureAlgorithm.EcDsaWithSha256:
                    return "SHA256WITHECDSA";
                case SignatureAlgorithm.EcDsaWithSha384:
                    return "SHA384WITHECDSA";
                case SignatureAlgorithm.EcDsaWithSha512:
                    return "SHA512WITHECDSA";
                case SignatureAlgorithm.GostR3411x94WithGostR3410x94:
                    return "GOST3411WITHGOST3410";
                case SignatureAlgorithm.GostR3411x94WithGostR3410x2001:
                    return "GOST3411WITHECGOST3410";
                default:
                    throw new NotSupportedException("this algorithm is not supported: " + signatureAlgorithm);
            }
        }

        private class DerObjectValue
        {
            public DerObjectValue(
                DerObjectIdentifier identifier,
                string value)
            {
                this.Identifier = identifier;
                this.Value = value;
            }

            public DerObjectIdentifier Identifier { get; }

            public string Value { get; }
        }

        private class SslCreationInfo
        {
            public Asn1SignatureFactory SignatureFactory { get; set; }
            
            public X509Name Subject { get; set; }

            public IReadOnlyDictionary<DerObjectIdentifier, X509Extension> OidToExtensionMap { get; set; }
        }
    }
}
