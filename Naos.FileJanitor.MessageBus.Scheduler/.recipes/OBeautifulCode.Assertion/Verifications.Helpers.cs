// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Verifications.Helpers.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using global::System;
    using global::System.Collections;
    using global::System.Collections.Concurrent;
    using global::System.Collections.Generic;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Globalization;
    using global::System.Linq;
    using global::System.Reflection;
    using global::System.Text.RegularExpressions;

    using OBeautifulCode.Equality.Recipes;

    using static global::System.FormattableString;

    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "A generalized assertion library is going to require lots of types.")]
#if !OBeautifulCodeAssertionSolution
    internal
#else
    public
#endif
    static partial class Verifications
    {
        private const int BuildReadOnlyCollectionVerificationParameterToStringMaxItems = 10;

        private static readonly MethodInfo GetDefaultValueOpenGenericMethodInfo = ((Func<object>)GetDefaultValue<object>).Method.GetGenericMethodDefinition();

        private static readonly ConcurrentDictionary<Type, MethodInfo> CachedGetDefaultValueTypeToMethodInfoMap = new ConcurrentDictionary<Type, MethodInfo>();

        private static readonly MethodInfo IsEqualToOpenGenericMethodInfo = typeof(EqualityExtensions).GetMethod(nameof(EqualityExtensions.IsEqualTo))?.GetGenericMethodDefinition();

        private static readonly MethodInfo IsSequenceEqualToOpenGenericMethodInfo = typeof(EqualityExtensions).GetMethod(nameof(EqualityExtensions.IsSequenceEqualTo))?.GetGenericMethodDefinition();

        private static readonly MethodInfo IsUnorderedEqualToOpenGenericMethodInfo = typeof(EqualityExtensions).GetMethod(nameof(EqualityExtensions.IsUnorderedEqualTo))?.GetGenericMethodDefinition();

        private static readonly ConcurrentDictionary<Type, MethodInfo> CachedTypeToIsEqualToMethodInfoMap = new ConcurrentDictionary<Type, MethodInfo>();

        private static readonly ConcurrentDictionary<Type, MethodInfo> CachedTypeToIsSequenceEqualToMethodInfoMap = new ConcurrentDictionary<Type, MethodInfo>();

        private static readonly ConcurrentDictionary<Type, MethodInfo> CachedTypeToIsUnorderedEqualToMethodInfoMap = new ConcurrentDictionary<Type, MethodInfo>();

        private static readonly MethodInfo CompareUsingDefaultComparerOpenGenericMethodInfo = ((Func<object, object, CompareOutcome>)CompareUsingDefaultComparer).Method.GetGenericMethodDefinition();

        private static readonly ConcurrentDictionary<Type, MethodInfo> CachedCompareUsingDefaultComparerTypeToMethodInfoMap = new ConcurrentDictionary<Type, MethodInfo>();

        private static readonly Regex ValidateEmailAddressRegex = new Regex(@"^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture);

        private enum CompareOutcome
        {
            Value1LessThanValue2,

            Value1EqualsValue2,

            Value1GreaterThanValue2,
        }

        private static object GetDefaultValue(
            Type type)
        {
            if (!CachedGetDefaultValueTypeToMethodInfoMap.ContainsKey(type))
            {
                CachedGetDefaultValueTypeToMethodInfoMap.TryAdd(type, GetDefaultValueOpenGenericMethodInfo.MakeGenericMethod(type));
            }

            var result = CachedGetDefaultValueTypeToMethodInfoMap[type].Invoke(null, null);

            return result;
        }

        private static bool AreEqual(
            Type type,
            object value1,
            object value2)
        {
            if (!CachedTypeToIsEqualToMethodInfoMap.ContainsKey(type))
            {
                CachedTypeToIsEqualToMethodInfoMap.TryAdd(type, IsEqualToOpenGenericMethodInfo.MakeGenericMethod(type));
            }

            var result = (bool)CachedTypeToIsEqualToMethodInfoMap[type].Invoke(null, new[] { value1, value2, null });

            return result;
        }

        private static bool AreSequenceEqual(
            Type elementType,
            object value1,
            object value2,
            object elementComparer)
        {
            if (!CachedTypeToIsSequenceEqualToMethodInfoMap.ContainsKey(elementType))
            {
                CachedTypeToIsSequenceEqualToMethodInfoMap.TryAdd(elementType, IsSequenceEqualToOpenGenericMethodInfo.MakeGenericMethod(elementType));
            }

            var result = (bool)CachedTypeToIsSequenceEqualToMethodInfoMap[elementType].Invoke(null, new[] { value1, value2, elementComparer });

            return result;
        }

        private static bool AreUnorderedEqual(
            Type elementType,
            object value1,
            object value2,
            object elementComparer)
        {
            if (!CachedTypeToIsUnorderedEqualToMethodInfoMap.ContainsKey(elementType))
            {
                CachedTypeToIsUnorderedEqualToMethodInfoMap.TryAdd(elementType, IsUnorderedEqualToOpenGenericMethodInfo.MakeGenericMethod(elementType));
            }

            var result = (bool)CachedTypeToIsUnorderedEqualToMethodInfoMap[elementType].Invoke(null, new[] { value1, value2, elementComparer });

            return result;
        }

        private static CompareOutcome CompareUsingDefaultComparer<T>(
            T x,
            T y)
        {
            var comparison = Comparer<T>.Default.Compare(x, y);

            CompareOutcome result;

            if (comparison < 0)
            {
                result = CompareOutcome.Value1LessThanValue2;
            }
            else if (comparison == 0)
            {
                result = CompareOutcome.Value1EqualsValue2;
            }
            else
            {
                result = CompareOutcome.Value1GreaterThanValue2;
            }

            return result;
        }

        private static CompareOutcome CompareUsingDefaultComparer(
            Type type,
            object value1,
            object value2)
        {
            if (!CachedCompareUsingDefaultComparerTypeToMethodInfoMap.ContainsKey(type))
            {
                CachedCompareUsingDefaultComparerTypeToMethodInfoMap.TryAdd(type, CompareUsingDefaultComparerOpenGenericMethodInfo.MakeGenericMethod(type));
            }

            // note that the call is ultimately, via reflection, to Compare(T, T)
            // as such, reflection will throw an ArgumentException if the types of value1 and value2 are
            // not "convertible" to the specified type.  It's a pretty complicated heuristic:
            // https://stackoverflow.com/questions/34433043/check-whether-propertyinfo-setvalue-will-throw-an-argumentexception
            // Instead of relying on this heuristic, we just check upfront that value2's type == the specified type
            // (value1's type will always be the specified type).  This constrains our capabilities - for example, we
            // can't compare an integer to a decimal.  That said, we feel like this is a good constraint in an
            // assertion framework.  We'd rather be forced to make the types align than get a false negative
            // (a verification passes when it should fail).

            // otherwise, if reflection is able to call Compare(T, T), then ArgumentException can be thrown if
            // Type T does not have a working default comparer (see TypeExtensions.HasDefaultWorkingComparer())
            // However we already check for this upfront in ThrowIfVerifiableItemTypeDoesNotHaveWorkingDefaultComparer
            var result = (CompareOutcome)CachedCompareUsingDefaultComparerTypeToMethodInfoMap[type].Invoke(null, new[] { value1, value2 });

            return result;
        }

        private static T GetDefaultValue<T>()
        {
            var result = default(T);

            return result;
        }

        private static int GetElementCount(
            IEnumerable value)
        {
            var result = 0;

            if (value is ICollection collection)
            {
                result = collection.Count;
            }
            else
            {
                var enumerator = value.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    ++result;
                }
            }

            return result;
        }

        private static void ThrowIfMalformedRange(
            IReadOnlyList<VerificationParameter> verificationParameters)
        {
            // the public BeInRange/NotBeInRange is generic and guarantees that minimum and maximum are of the same type
            var rangeIsMalformed = CompareUsingDefaultComparer(verificationParameters[0].ParameterType, verificationParameters[0].Value, verificationParameters[1].Value) == CompareOutcome.Value1GreaterThanValue2;

            if (rangeIsMalformed)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, MalformedRangeExceptionMessage, verificationParameters[0].Name, verificationParameters[1].Name, verificationParameters[0].Value.ToStringInErrorMessage(), verificationParameters[1].Value.ToStringInErrorMessage());

                ThrowImproperUseOfFramework(errorMessage);
            }
        }

        private static bool IsValidEmailAddress(
            this string emailAddress)
        {
            var result = !string.IsNullOrWhiteSpace(emailAddress) && (ValidateEmailAddressRegex.Match(emailAddress).Length > 0);

            return result;
        }

        private static string BuildReadOnlyCollectionVerificationParameterToString<T>(
            this IReadOnlyCollection<T> verificationParameter,
            int maxItems)
        {
            var verificationParameterToStrings = verificationParameter.Take(maxItems).Select(_ => ToStringInErrorMessage(_)).ToArray();

            var result = Invariant($"[{string.Join(", ", verificationParameterToStrings)}");

            if (verificationParameter.Count() > maxItems)
            {
                result = result + ", ...";
            }

            result = result + "]";

            return result;
        }
    }
}
