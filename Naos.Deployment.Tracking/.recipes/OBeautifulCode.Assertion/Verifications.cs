// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Verifications.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using global::System;
    using global::System.Collections;
    using global::System.Collections.Generic;
    using global::System.Globalization;
    using global::System.Linq;
    using global::System.Text.RegularExpressions;

    using OBeautifulCode.Equality.Recipes;
    using OBeautifulCode.Type.Recipes;

    using static global::System.FormattableString;

    /// <summary>
    /// Contains all verifications that can be applied to an <see cref="AssertionTracker"/>.
    /// </summary>
#if !OBeautifulCodeAssertionSolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Assertion.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static partial class Verifications
    {
        /// <summary>
        /// Verifies that the reference type or nullable subject is null.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeNullInternal,
                Name = nameof(BeNull),
                TypeValidations = VerifiableItemMustBeAssignableToNullTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the reference type or nullable subject is not null.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeNullInternal,
                Name = nameof(NotBeNull),
                TypeValidations = VerifiableItemMustBeAssignableToNullTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool or bool? subject is true.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeTrue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeTrueInternal,
                Name = nameof(BeTrue),
                TypeValidations = VerifiableItemMustBeBooleanOrNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool or bool? subject is not true.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeTrue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeTrueInternal,
                Name = nameof(NotBeTrue),
                TypeValidations = VerifiableItemMustBeBooleanOrNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool or bool? subject is false.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeFalse(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeFalseInternal,
                Name = nameof(BeFalse),
                TypeValidations = VerifiableItemMustBeBooleanOrNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool? or bool? subject is not false.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeFalse(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeFalseInternal,
                Name = nameof(NotBeFalse),
                TypeValidations = VerifiableItemMustBeBooleanOrNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }
        
        /// <summary>
        /// Verifies that the bool? subject is true, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeTrueWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeTrueWhenNotNullInternal,
                Name = nameof(BeTrueWhenNotNull),
                TypeValidations = VerifiableItemMustBeNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool? subject is not true, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeTrueWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeTrueWhenNotNullInternal,
                Name = nameof(NotBeTrueWhenNotNull),
                TypeValidations = VerifiableItemMustBeNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool? subject is false, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeFalseWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeFalseWhenNotNullInternal,
                Name = nameof(BeFalseWhenNotNull),
                TypeValidations = VerifiableItemMustBeNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool? subject is not false, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeFalseWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeFalseWhenNotNullInternal,
                Name = nameof(NotBeFalseWhenNotNull),
                TypeValidations = VerifiableItemMustBeNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is neither null nor whitespace.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorWhiteSpace(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeNullNorWhiteSpaceInternal,
                Name = nameof(NotBeNullNorWhiteSpace),
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is null or not white space.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeNullOrNotWhiteSpace(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeNullOrNotWhiteSpaceInternal,
                Name = nameof(BeNullOrNotWhiteSpace),
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the guid or guid? subject is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEmptyGuid(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEmptyGuidInternal,
                Name = nameof(BeEmptyGuid),
                TypeValidations = VerifiableItemMustBeGuidOrNullableGuidTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the guid or guid? subject is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyGuid(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyGuidInternal,
                Name = nameof(NotBeEmptyGuid),
                TypeValidations = VerifiableItemMustBeGuidOrNullableGuidTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEmptyString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEmptyStringInternal,
                Name = nameof(BeEmptyString),
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyStringInternal,
                Name = nameof(NotBeEmptyString),
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEmptyEnumerable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEmptyEnumerableInternal,
                Name = nameof(BeEmptyEnumerable),
                TypeValidations = VerifiableItemMustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyEnumerable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyEnumerableInternal,
                Name = nameof(NotBeEmptyEnumerable),
                TypeValidations = VerifiableItemMustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject is not empty, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyEnumerableWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyEnumerableWhenNotNullInternal,
                Name = nameof(NotBeEmptyEnumerableWhenNotNull),
                TypeValidations = VerifiableItemMustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEmptyDictionary(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEmptyDictionaryInternal,
                Name = nameof(BeEmptyDictionary),
                TypeValidations = VerifiableItemMustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyDictionary(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyDictionaryInternal,
                Name = nameof(NotBeEmptyDictionary),
                TypeValidations = VerifiableItemMustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is not empty, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyDictionaryWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyDictionaryWhenNotNullInternal,
                Name = nameof(NotBeEmptyDictionaryWhenNotNull),
                TypeValidations = VerifiableItemMustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains at least one null element.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainSomeNullElements(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainSomeNullElementsInternal,
                Name = nameof(ContainSomeNullElements),
                TypeValidations = VerifiableItemEnumerableElementTypeMustBeAssignableToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not contain any null elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainAnyNullElements(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainAnyNullElementsInternal,
                Name = nameof(NotContainAnyNullElements),
                TypeValidations = VerifiableItemEnumerableElementTypeMustBeAssignableToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not contain any null elements, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainAnyNullElementsWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainAnyNullElementsWhenNotNullInternal,
                Name = nameof(NotContainAnyNullElementsWhenNotNull),
                TypeValidations = VerifiableItemEnumerableElementTypeMustBeAssignableToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject contains at least one null value.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainSomeKeyValuePairsWithNullValue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainSomeKeyValuePairsWithNullValueInternal,
                Name = nameof(ContainSomeKeyValuePairsWithNullValue),
                TypeValidations = VerifiableItemMustBeDictionaryWhoseValueTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject does not contain any null values.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainAnyKeyValuePairsWithNullValue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainAnyKeyValuePairsWithNullValueInternal,
                Name = nameof(NotContainAnyKeyValuePairsWithNullValue),
                TypeValidations = VerifiableItemMustBeDictionaryWhoseValueTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject does not contain any null values, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainAnyKeyValuePairsWithNullValueWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainAnyKeyValuePairsWithNullValueWhenNotNullInternal,
                Name = nameof(NotContainAnyKeyValuePairsWithNullValueWhenNotNull),
                TypeValidations = VerifiableItemMustBeDictionaryWhoseValueTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject contains a specified key.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="keyToSearchFor">The key to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainKey<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T keyToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (keyToSearchFor == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(ContainKey), nameof(keyToSearchFor));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainKeyInternal,
                Name = nameof(ContainKey),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(keyToSearchFor),
                        Value = keyToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemDictionaryKeyTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject does not contain a specified key.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="keyToSearchFor">The key to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainKey<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T keyToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (keyToSearchFor == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotContainKey), nameof(keyToSearchFor));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainKeyInternal,
                Name = nameof(NotContainKey),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(keyToSearchFor),
                        Value = keyToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemDictionaryKeyTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject contains a specified key, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="keyToSearchFor">The key to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainKeyWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T keyToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (keyToSearchFor == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(ContainKeyWhenNotNull), nameof(keyToSearchFor));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainKeyWhenNotNullInternal,
                Name = nameof(ContainKeyWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(keyToSearchFor),
                        Value = keyToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemDictionaryKeyTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject does not contain a specified key, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="keyToSearchFor">The key to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainKeyWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T keyToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (keyToSearchFor == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotContainKeyWhenNotNull), nameof(keyToSearchFor));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainKeyWhenNotNullInternal,
                Name = nameof(NotContainKeyWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(keyToSearchFor),
                        Value = keyToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemDictionaryKeyTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject is not null nor empty.
        /// </summary>
        /// <remarks>
        /// This verification is effectively the same as <see cref="NotBeEmptyEnumerable"/> and exists for completeness.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyEnumerable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyEnumerableInternal,
                Name = nameof(NotBeNullNorEmptyEnumerable),
                TypeValidations = VerifiableItemMustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject not empty nor contains any null elements, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyEnumerableNorContainAnyNullsWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verificationName = nameof(NotBeEmptyEnumerableNorContainAnyNullsWhenNotNull);

            var verification1 = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyEnumerableWhenNotNullInternal,
                Name = verificationName,
                TypeValidations = VerifiableItemEnumerableElementTypeMustBeAssignableToNullValidations,
                Data = data,
            };

            var verification2 = new Verification
            {
                Because = because,
                Handler = NotContainAnyNullElementsWhenNotNullInternal,
                Name = verificationName,
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification1);
            assertionTracker.ExecuteVerification(verification2);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject is not null nor empty nor contains any null elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyEnumerableNorContainAnyNulls(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verificationName = nameof(NotBeNullNorEmptyEnumerableNorContainAnyNulls);

            var verification1 = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyEnumerableInternal,
                Name = verificationName,
                TypeValidations = VerifiableItemEnumerableElementTypeMustBeAssignableToNullValidations,
                Data = data,
            };

            var verification2 = new Verification
            {
                Because = because,
                Handler = NotContainAnyNullElementsInternal,
                Name = verificationName,
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification1);
            assertionTracker.ExecuteVerification(verification2);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is not empty nor contains any null values, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyDictionaryNorContainAnyNullValuesWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verificationName = nameof(NotBeEmptyDictionaryNorContainAnyNullValuesWhenNotNull);

            var verification1 = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyDictionaryWhenNotNullInternal,
                Name = verificationName,
                TypeValidations = VerifiableItemMustBeDictionaryWhoseValueTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            var verification2 = new Verification
            {
                Because = because,
                Handler = NotContainAnyKeyValuePairsWithNullValueWhenNotNullInternal,
                Name = verificationName,
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification1);
            assertionTracker.ExecuteVerification(verification2);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is not null nor empty nor contains any null values.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyDictionaryNorContainAnyNullValues(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verificationName = nameof(NotBeNullNorEmptyDictionaryNorContainAnyNullValues);

            var verification1 = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyDictionaryInternal,
                Name = verificationName,
                TypeValidations = VerifiableItemMustBeDictionaryWhoseValueTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            var verification2 = new Verification
            {
                Because = because,
                Handler = NotContainAnyKeyValuePairsWithNullValueInternal,
                Name = verificationName,
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification1);
            assertionTracker.ExecuteVerification(verification2);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is not null nor empty.
        /// </summary>
        /// <remarks>
        /// This verification is effectively the same as <see cref="NotBeEmptyDictionary"/> and exists for completeness.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyDictionary(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyDictionaryInternal,
                Name = nameof(NotBeNullNorEmptyDictionary),
                TypeValidations = VerifiableItemMustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is equal to default(T).
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeDefault(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeDefaultInternal,
                Name = nameof(BeDefault),
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not equal to default(T).
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeDefault(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeDefaultInternal,
                Name = nameof(NotBeDefault),
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is less than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeLessThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeLessThanInternal,
                Name = nameof(BeLessThan),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not less than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeLessThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeLessThanInternal,
                Name = nameof(NotBeLessThan),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is greater than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeGreaterThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeGreaterThanInternal,
                Name = nameof(BeGreaterThan),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not greater than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeGreaterThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeGreaterThanInternal,
                Name = nameof(NotBeGreaterThan),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is less than or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeLessThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeLessThanOrEqualToInternal,
                Name = nameof(BeLessThanOrEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not less or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeLessThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeLessThanOrEqualToInternal,
                Name = nameof(NotBeLessThanOrEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is greater than or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeGreaterThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeGreaterThanOrEqualToInternal,
                Name = nameof(BeGreaterThanOrEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not greater than or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeGreaterThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeGreaterThanOrEqualToInternal,
                Name = nameof(NotBeGreaterThanOrEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is less than some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeLessThanWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeLessThanWhenNotNullInternal,
                Name = nameof(BeLessThanWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToNullAndInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not less than some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeLessThanWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeLessThanWhenNotNullInternal,
                Name = nameof(NotBeLessThanWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToNullAndInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is greater than some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeGreaterThanWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeGreaterThanWhenNotNullInternal,
                Name = nameof(BeGreaterThanWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToNullAndInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not greater than some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeGreaterThanWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeGreaterThanWhenNotNullInternal,
                Name = nameof(NotBeGreaterThanWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToNullAndInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is less than or equal to some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeLessThanOrEqualToWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeLessThanOrEqualToWhenNotNullInternal,
                Name = nameof(BeLessThanOrEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToNullAndInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not less or equal to some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeLessThanOrEqualToWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeLessThanOrEqualToWhenNotNullInternal,
                Name = nameof(NotBeLessThanOrEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToNullAndInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is greater than or equal to some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeGreaterThanOrEqualToWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeGreaterThanOrEqualToWhenNotNullInternal,
                Name = nameof(BeGreaterThanOrEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToNullAndInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not greater than or equal to some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeGreaterThanOrEqualToWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeGreaterThanOrEqualToWhenNotNullInternal,
                Name = nameof(NotBeGreaterThanOrEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToNullAndInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEqualToInternal,
                Name = nameof(BeEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEqualToInternal,
                Name = nameof(NotBeEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is equal to some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEqualToWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEqualToWhenNotNullInternal,
                Name = nameof(BeEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not equal to some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEqualToWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEqualToWhenNotNullInternal,
                Name = nameof(NotBeEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject has the same elements in the same order as a specified IEnumerable value.
        /// </summary>
        /// <typeparam name="TElement">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to use the result of <see cref="EqualityComparerHelper.GetEqualityComparerToUse{T}(IEqualityComparer{T})"/>.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeSequenceEqualTo<TElement>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IEnumerable<TElement> comparisonValue,
            IEqualityComparer<TElement> elementComparer = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeSequenceEqualToInternal,
                Name = nameof(BeSequenceEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(IEnumerable<TElement>),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(elementComparer),
                        Value = elementComparer,
                        ParameterType = typeof(IEqualityComparer<TElement>),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToFirstVerificationParameterType,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not have the same elements in the same order as a specified IEnumerable value.
        /// </summary>
        /// <typeparam name="TElement">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to use the result of <see cref="EqualityComparerHelper.GetEqualityComparerToUse{T}(IEqualityComparer{T})"/>.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeSequenceEqualTo<TElement>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IEnumerable<TElement> comparisonValue,
            IEqualityComparer<TElement> elementComparer = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeSequenceEqualToInternal,
                Name = nameof(NotBeSequenceEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(IEnumerable<TElement>),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(elementComparer),
                        Value = elementComparer,
                        ParameterType = typeof(IEqualityComparer<TElement>),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToFirstVerificationParameterType,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject has the same elements in the same order as a specified IEnumerable value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="TElement">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to use the result of <see cref="EqualityComparerHelper.GetEqualityComparerToUse{T}(IEqualityComparer{T})"/>.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeSequenceEqualToWhenNotNull<TElement>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IEnumerable<TElement> comparisonValue,
            IEqualityComparer<TElement> elementComparer = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeSequenceEqualToWhenNotNullInternal,
                Name = nameof(BeSequenceEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(IEnumerable<TElement>),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(elementComparer),
                        Value = elementComparer,
                        ParameterType = typeof(IEqualityComparer<TElement>),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToFirstVerificationParameterType,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not have the same elements in the same order as a specified IEnumerable value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="TElement">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to use the result of <see cref="EqualityComparerHelper.GetEqualityComparerToUse{T}(IEqualityComparer{T})"/>.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeSequenceEqualToWhenNotNull<TElement>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IEnumerable<TElement> comparisonValue,
            IEqualityComparer<TElement> elementComparer = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeSequenceEqualToWhenNotNullInternal,
                Name = nameof(NotBeSequenceEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(IEnumerable<TElement>),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(elementComparer),
                        Value = elementComparer,
                        ParameterType = typeof(IEqualityComparer<TElement>),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToFirstVerificationParameterType,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject has the exact same elements in any order as a specified IEnumerable value.
        /// Every unique element in the first set has to appear in the second set the same number of times it appears in the first
        /// </summary>
        /// <typeparam name="TElement">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to use the result of <see cref="EqualityComparerHelper.GetEqualityComparerToUse{T}(IEqualityComparer{T})"/>.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeUnorderedEqualTo<TElement>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IEnumerable<TElement> comparisonValue,
            IEqualityComparer<TElement> elementComparer = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeUnorderedEqualToInternal,
                Name = nameof(BeUnorderedEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(IEnumerable<TElement>),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(elementComparer),
                        Value = elementComparer,
                        ParameterType = typeof(IEqualityComparer<TElement>),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToFirstVerificationParameterType,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not have the exact same elements in any order as a specified IEnumerable value.
        /// Every unique element in the first set must not appear in the second set the same number of times it appears in the first
        /// </summary>
        /// <typeparam name="TElement">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to use the result of <see cref="EqualityComparerHelper.GetEqualityComparerToUse{T}(IEqualityComparer{T})"/>.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeUnorderedEqualTo<TElement>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IEnumerable<TElement> comparisonValue,
            IEqualityComparer<TElement> elementComparer = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeUnorderedEqualToInternal,
                Name = nameof(NotBeUnorderedEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(IEnumerable<TElement>),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(elementComparer),
                        Value = elementComparer,
                        ParameterType = typeof(IEqualityComparer<TElement>),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToFirstVerificationParameterType,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject has the exact same elements in any order as a specified IEnumerable value, when not null.
        /// If null, no exception is thrown.  Otherwise, every unique element in the first set has to appear in the second set the same number of times it appears in the first.
        /// </summary>
        /// <typeparam name="TElement">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to use the result of <see cref="EqualityComparerHelper.GetEqualityComparerToUse{T}(IEqualityComparer{T})"/>.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeUnorderedEqualToWhenNotNull<TElement>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IEnumerable<TElement> comparisonValue,
            IEqualityComparer<TElement> elementComparer = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeUnorderedEqualToWhenNotNullInternal,
                Name = nameof(BeUnorderedEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(IEnumerable<TElement>),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(elementComparer),
                        Value = elementComparer,
                        ParameterType = typeof(IEqualityComparer<TElement>),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToFirstVerificationParameterType,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not have the exact same elements in any order as a specified IEnumerable value, when not null.
        /// If null, no exception is thrown.  Otherwise, every unique element in the first set must not appear in the second set the same number of times it appears in the first
        /// </summary>
        /// <typeparam name="TElement">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="elementComparer">Optional equality comparer to use to compare the elements.  Default is to use the result of <see cref="EqualityComparerHelper.GetEqualityComparerToUse{T}(IEqualityComparer{T})"/>.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeUnorderedEqualToWhenNotNull<TElement>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IEnumerable<TElement> comparisonValue,
            IEqualityComparer<TElement> elementComparer = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeUnorderedEqualToWhenNotNullInternal,
                Name = nameof(NotBeUnorderedEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(IEnumerable<TElement>),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(elementComparer),
                        Value = elementComparer,
                        ParameterType = typeof(IEqualityComparer<TElement>),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeAssignableToFirstVerificationParameterType,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }
        
        /// <summary>
        /// Verifies that the subject is an element of the specified collection.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValues">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeElementIn<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<T> comparisonValues,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValues == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeElementIn), nameof(comparisonValues));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeElementInInternal,
                Name = nameof(BeElementIn),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValues),
                        Value = comparisonValues,
                        ParameterType = typeof(IReadOnlyCollection<T>),
                        ValueToStringFunc = () => comparisonValues.BuildReadOnlyCollectionVerificationParameterToString(BuildReadOnlyCollectionVerificationParameterToStringMaxItems),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeEqualToAllVerificationParameterEnumerableElementTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not an element of the specified collection.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValues">The values to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeElementIn<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<T> comparisonValues,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValues == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeElementIn), nameof(comparisonValues));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeElementInInternal,
                Name = nameof(NotBeElementIn),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValues),
                        Value = comparisonValues,
                        ParameterType = typeof(IReadOnlyCollection<T>),
                        ValueToStringFunc = () => comparisonValues.BuildReadOnlyCollectionVerificationParameterToString(BuildReadOnlyCollectionVerificationParameterToStringMaxItems),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeEqualToAllVerificationParameterEnumerableElementTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is an element of the specified collection, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValues">The values to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeElementInWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<T> comparisonValues,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValues == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeElementInWhenNotNull), nameof(comparisonValues));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeElementInWhenNotNullInternal,
                Name = nameof(BeElementInWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValues),
                        Value = comparisonValues,
                        ParameterType = typeof(IReadOnlyCollection<T>),
                        ValueToStringFunc = () => comparisonValues.BuildReadOnlyCollectionVerificationParameterToString(BuildReadOnlyCollectionVerificationParameterToStringMaxItems),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeEqualToAllVerificationParameterEnumerableElementTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not an element of the specified collection, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValues">The values to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeElementInWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<T> comparisonValues,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValues == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeElementInWhenNotNull), nameof(comparisonValues));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeElementInWhenNotNullInternal,
                Name = nameof(NotBeElementInWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValues),
                        Value = comparisonValues,
                        ParameterType = typeof(IReadOnlyCollection<T>),
                        ValueToStringFunc = () => comparisonValues.BuildReadOnlyCollectionVerificationParameterToString(BuildReadOnlyCollectionVerificationParameterToStringMaxItems),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeEqualToAllVerificationParameterEnumerableElementTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is within a specified range.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="minimum">The minimum comparison value (start of the range).</param>
        /// <param name="maximum">The maximum comparison value (end of the range).</param>
        /// <param name="endpointDelineation">Optional instruction on whether the range is inclusive or exclusive of the endpoints.  Default is to include both the <paramref name="minimum"/> and <paramref name="maximum"/> in the range.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeInRange<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T minimum,
            T maximum,
            Range endpointDelineation = Range.IncludesMinimumAndMaximum,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (endpointDelineation != Range.IncludesMinimumAndMaximum)
            {
                throw new NotImplementedException("This endpoint delineation is not yet implemented: " + endpointDelineation);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeInRangeInternal,
                Name = nameof(BeInRange),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(minimum),
                        Value = minimum,
                        ParameterType = typeof(T),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(maximum),
                        Value = maximum,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not within a specified range.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="minimum">The minimum comparison value (start of the range).</param>
        /// <param name="maximum">The maximum comparison value (end of the range).</param>
        /// <param name="endpointDelineation">Optional instruction on whether the range is inclusive or exclusive of the endpoints.  Default is to include both the <paramref name="minimum"/> and <paramref name="maximum"/> in the range.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeInRange<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T minimum,
            T maximum,
            Range endpointDelineation = Range.IncludesMinimumAndMaximum,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (endpointDelineation != Range.IncludesMinimumAndMaximum)
            {
                throw new NotImplementedException("This endpoint delineation is not yet implemented: " + endpointDelineation + ".");
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeInRangeInternal,
                Name = nameof(NotBeInRange),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(minimum),
                        Value = minimum,
                        ParameterType = typeof(T),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(maximum),
                        Value = maximum,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeInequalityComparableToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains a specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainElement<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainElementInternal,
                Name = nameof(ContainElement),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemEnumerableElementTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not contain a specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainElement<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainElementInternal,
                Name = nameof(NotContainElement),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemEnumerableElementTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains a specified value, when not null.
        /// If null, no exception is thrown
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainElementWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainElementWhenNotNullInternal,
                Name = nameof(ContainElementWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemEnumerableElementTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not contain a specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainElementWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainElementWhenNotNullInternal,
                Name = nameof(NotContainElementWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemEnumerableElementTypeMustBeEqualToAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains only distinct elements
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainOnlyDistinctElements(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainOnlyDistinctElementsInternal,
                Name = nameof(ContainOnlyDistinctElements),
                TypeValidations = VerifiableItemMustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains only distinct elements, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainOnlyDistinctElementsWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainOnlyDistinctElementsWhenNotNullInternal,
                Name = nameof(ContainOnlyDistinctElementsWhenNotNull),
                TypeValidations = VerifiableItemMustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is alphabetic.
        /// </summary>
        /// <remarks>
        /// An empty string is considered to be alphabetic.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="otherAllowedCharacters">Optional set of other characters that are allowed (e.g. '-').  Default is none (strict definition of alphabetic).</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAlphabetic(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<char> otherAllowedCharacters = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAlphabeticInternal,
                Name = nameof(BeAlphabetic),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(otherAllowedCharacters),
                        Value = otherAllowedCharacters,
                        ParameterType = typeof(IReadOnlyCollection<char>),
                        ValueToStringFunc = () =>
                        {
                            string result;
                            if (otherAllowedCharacters == null)
                            {
                                result = NullValueToString;
                            }
                            else if (otherAllowedCharacters.Count == 0)
                            {
                                result = EmptyEnumerableToString;
                            }
                            else
                            {
                                var otherAllowedCharactersToString = otherAllowedCharacters.Select(_ => Invariant($"'{_}'")).ToArray();

                                result = Invariant($"[{string.Join(", ", otherAllowedCharactersToString)}]");
                            }

                            return result;
                        },
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is alphanumeric.
        /// </summary>
        /// <remarks>
        /// An empty string is considered to be alphanumeric.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="otherAllowedCharacters">Optional set of other characters that are allowed (e.g. '-').  Default is none (strict definition of alphanumeric).</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAlphanumeric(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<char> otherAllowedCharacters = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAlphanumericInternal,
                Name = nameof(BeAlphanumeric),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(otherAllowedCharacters),
                        Value = otherAllowedCharacters,
                        ParameterType = typeof(IReadOnlyCollection<char>),
                        ValueToStringFunc = () =>
                        {
                            string result;
                            if (otherAllowedCharacters == null)
                            {
                                result = NullValueToString;
                            }
                            else if (otherAllowedCharacters.Count == 0)
                            {
                                result = EmptyEnumerableToString;
                            }
                            else
                            {
                                var otherAllowedCharactersToString = otherAllowedCharacters.Select(_ => Invariant($"'{_}'")).ToArray();

                                result = Invariant($"[{string.Join(", ", otherAllowedCharactersToString)}]");
                            }

                            return result;
                        },
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is in the ASCII printable set (ASCII 32-126).
        /// </summary>
        /// <remarks>
        /// An empty string is considered to be printable.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="treatNewLineAsPrintable">Optional value indicating whether to treat newline as printable.  Default value is false; newline will not be treated as printable.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAsciiPrintable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            bool treatNewLineAsPrintable = false,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAsciiPrintableInternal,
                Name = nameof(BeAsciiPrintable),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(treatNewLineAsPrintable),
                        Value = treatNewLineAsPrintable,
                        ParameterType = typeof(bool),
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that a regex finds a match in the string subject.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="regex">The regex to use.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeMatchedByRegex(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Regex regex,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (regex == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeMatchedByRegex), nameof(regex));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeMatchedByRegexInternal,
                Name = nameof(BeMatchedByRegex),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(regex),
                        Value = regex,
                        ParameterType = typeof(Regex),

                        // ReSharper disable once PossibleNullReferenceException
                        ValueToStringFunc = regex.ToString,
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that a regex does not find a match in the string subject.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="regex">The regex to use.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeMatchedByRegex(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Regex regex,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (regex == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeMatchedByRegex), nameof(regex));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeMatchedByRegexInternal,
                Name = nameof(NotBeMatchedByRegex),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(regex),
                        Value = regex,
                        ParameterType = typeof(Regex),

                        // ReSharper disable once PossibleNullReferenceException
                        ValueToStringFunc = regex.ToString,
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject starts with a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="comparisonType">Optional value that determines how the string subject and <paramref name="comparisonValue"/> are compared.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker StartWith(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            StringComparison? comparisonType = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(StartWith), nameof(comparisonValue));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = StartWithInternal,
                Name = nameof(StartWith),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(comparisonType),
                        Value = comparisonType,
                        ParameterType = typeof(StringComparison),
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject does not start with a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="comparisonType">Optional value that determines how the string subject and <paramref name="comparisonValue"/> are compared.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotStartWith(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            StringComparison? comparisonType = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotStartWith), nameof(comparisonValue));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotStartWithInternal,
                Name = nameof(NotStartWith),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(comparisonType),
                        Value = comparisonType,
                        ParameterType = typeof(StringComparison),
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject ends with a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="comparisonType">Optional value that determines how the string subject and <paramref name="comparisonValue"/> are compared.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker EndWith(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            StringComparison? comparisonType = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(EndWith), nameof(comparisonValue));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = EndWithInternal,
                Name = nameof(EndWith),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(comparisonType),
                        Value = comparisonType,
                        ParameterType = typeof(StringComparison),
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject does not end with a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="comparisonType">Optional value that determines how the string subject and <paramref name="comparisonValue"/> are compared.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotEndWith(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            StringComparison? comparisonType = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotEndWith), nameof(comparisonValue));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotEndWithInternal,
                Name = nameof(NotEndWith),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(comparisonType),
                        Value = comparisonType,
                        ParameterType = typeof(StringComparison),
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the reference-type subject is the exact same object as the specified comparison value.
        /// </summary>
        /// <typeparam name="T">The type of subject.</typeparam>
        /// <remarks>
        /// Value types are boxed as object and thus they are never the same reference.
        /// This verification will throw for value types.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeSameReferenceAs<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeSameReferenceAsInternal,
                Name = nameof(BeSameReferenceAs),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeSameReferenceAsAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the reference-type subject is not the exact same object as the specified comparison value.
        /// </summary>
        /// <remarks>
        /// Value types are boxed as object and thus they are never the same reference.
        /// This verification will throw for value types.
        /// </remarks>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeSameReferenceAs<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeSameReferenceAsInternal,
                Name = nameof(NotBeSameReferenceAs),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = VerifiableItemTypeMustBeSameReferenceAsAllVerificationParameterTypesValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject contains a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(ContainString), nameof(comparisonValue));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainStringInternal,
                Name = nameof(ContainString),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject does not contain a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotContainString), nameof(comparisonValue));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainStringInternal,
                Name = nameof(NotContainString),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                },
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject has a specified number of elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="expectedCount">The expected number of elements.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker HaveCount(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            int expectedCount,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (expectedCount < 0)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsLessThanZeroErrorMessage, nameof(HaveCount), nameof(expectedCount), expectedCount);

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = HaveCountInternal,
                Name = nameof(HaveCount),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(expectedCount),
                        Value = expectedCount,
                        ParameterType = typeof(int),
                    },
                },
                TypeValidations = VerifiableItemMustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not has a specified number of elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="unexpectedCount">The unexpected number of elements.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotHaveCount(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            int unexpectedCount,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (unexpectedCount < 0)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsLessThanZeroErrorMessage, nameof(NotHaveCount), nameof(unexpectedCount), unexpectedCount);

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotHaveCountInternal,
                Name = nameof(NotHaveCount),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(unexpectedCount),
                        Value = unexpectedCount,
                        ParameterType = typeof(int),
                    },
                },
                TypeValidations = VerifiableItemMustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is of the specified type.
        /// </summary>
        /// <typeparam name="TExpected">The expected type.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeOfType<TExpected>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeOfTypeInternal,
                Name = nameof(BeOfType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(TExpected),
                        Value = typeof(TExpected),
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + typeof(TExpected).ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not of the specified type.
        /// </summary>
        /// <typeparam name="TUnexpected">The unexpected type.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeOfType<TUnexpected>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeOfTypeInternal,
                Name = nameof(NotBeOfType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(TUnexpected),
                        Value = typeof(TUnexpected),
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + typeof(TUnexpected).ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is of the specified type.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="expectedType">The expected type.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeOfType(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Type expectedType,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (expectedType == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeOfType), nameof(expectedType));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeOfTypeInternal,
                Name = nameof(BeOfType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(expectedType),
                        Value = expectedType,
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + expectedType.ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not of the specified type.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="unexpectedType">The unexpected type.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeOfType(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Type unexpectedType,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (unexpectedType == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeOfType), nameof(unexpectedType));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeOfTypeInternal,
                Name = nameof(NotBeOfType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(unexpectedType),
                        Value = unexpectedType,
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + unexpectedType.ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is assignable to the specified type.
        /// </summary>
        /// <typeparam name="TAssignable">The the assignable type.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAssignableToType<TAssignable>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAssignableToTypeInternal,
                Name = nameof(BeAssignableToType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(TAssignable),
                        Value = typeof(TAssignable),
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + typeof(TAssignable).ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not assignable to the specified type.
        /// </summary>
        /// <typeparam name="TUnassignable">The unassignable type.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeAssignableToType<TUnassignable>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeAssignableToTypeInternal,
                Name = nameof(NotBeAssignableToType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(TUnassignable),
                        Value = typeof(TUnassignable),
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + typeof(TUnassignable).ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is assignable to the specified type.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="assignableType">The assignable type.</param>
        /// <param name="treatUnboundGenericAsAssignableTo">Treats an unbound generic as a type that can be assigned to (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAssignableToType(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Type assignableType,
            bool treatUnboundGenericAsAssignableTo = false,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (assignableType == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeAssignableToType), nameof(assignableType));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAssignableToTypeInternal,
                Name = nameof(BeAssignableToType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(assignableType),
                        Value = assignableType,
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + assignableType.ToStringReadable() + "'",
                    },
                    new VerificationParameter
                    {
                        Name = nameof(treatUnboundGenericAsAssignableTo),
                        Value = treatUnboundGenericAsAssignableTo,
                        ParameterType = typeof(bool),
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not assignable to the specified type.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="unassignableType">The unassignable type.</param>
        /// <param name="treatUnboundGenericAsAssignableTo">Treats an unbound generic as a type that can be assigned to (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeAssignableToType(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Type unassignableType,
            bool treatUnboundGenericAsAssignableTo = false,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (unassignableType == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeAssignableToType), nameof(unassignableType));

                ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeAssignableToTypeInternal,
                Name = nameof(NotBeAssignableToType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(unassignableType),
                        Value = unassignableType,
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + unassignableType.ToStringReadable() + "'",
                    },
                    new VerificationParameter
                    {
                        Name = nameof(treatUnboundGenericAsAssignableTo),
                        Value = treatUnboundGenericAsAssignableTo,
                        ParameterType = typeof(bool),
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is in valid email format.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeValidEmailAddress(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeValidEmailAddressInternal,
                Name = nameof(BeValidEmailAddress),
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is not in valid email format.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeValidEmailAddress(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeValidEmailAddressInternal,
                Name = nameof(NotBeValidEmailAddress),
                TypeValidations = VerifiableItemMustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the DateTime or DateTime? subject has <see cref="DateTimeKind.Utc"/>.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeUtcDateTime(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeUtcDateTimeInternal,
                Name = nameof(BeUtcDateTime),
                TypeValidations = VerifiableItemMustBeDateTimeOrNullableDateTimeTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the DateTime? subject has <see cref="DateTimeKind.Utc"/>, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeUtcDateTimeWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeUtcDateTimeWhenNotNullInternal,
                Name = nameof(BeUtcDateTimeWhenNotNull),
                TypeValidations = VerifiableItemMustBeNullableDateTimeTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Always throws.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeOfTypeThatDoesNotExist(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = null,
                Name = nameof(BeOfTypeThatDoesNotExist),
                TypeValidations = AlwaysThrowTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }
    }
}
