// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Using.cs">
//   Copyright (c) 2016. All rights reserved.
//   Licensed under the MIT license. See LICENSE file in the project root for full license information.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Spritely.Redo source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Spritely.Redo
{
    using System;

    /// <summary>
    ///     The main entry point to start building a retriable function.
    /// </summary>
#if !SpritelyRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Spritely.Recipes", "See package version number")]
#pragma warning disable 0436
#endif
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Try", Justification = "This is intentially designed to have a matching name as try keyword because it does a very similar thing and the name should make this obvious.")]
    internal static partial class Using
    {
        /// <summary>
        /// Begins an retriable operation using the constant delay back-off strategy.
        /// </summary>
        /// <param name="delay">The delay.</param>
        /// <returns>A back-off strategy context.</returns>
        public static BackOffStrategy ConstantBackOff(TimeSpan delay)
        {
            return new BackOffStrategy(_ =>
            {
                var sleepTime = TimeSpan.FromMilliseconds(Math.Max(1, delay.TotalMilliseconds));

                return sleepTime;
            });
        }

        /// <summary>
        /// Begins an retriable operation using the linear delay back-off strategy.
        /// initial + (delta * attempt) where attempt is 0-based.
        /// </summary>
        /// <param name="initial">The initial delay.</param>
        /// <param name="delta">The delta to adjust delay by with each back-off.</param>
        /// <returns>
        /// A back-off strategy context.
        /// </returns>
        public static BackOffStrategy LinearBackOff(TimeSpan initial, TimeSpan delta)
        {
            return new BackOffStrategy(
                attempt =>
                {
                    var factor = attempt * delta.TotalMilliseconds;
                    var totalDelay = initial.TotalMilliseconds + factor;

                    var sleepTime = ConstrainBounds(totalDelay);

                    return sleepTime;
                });
        }

        /// <summary>
        /// Begins an retriable operation using the linear delay back-off strategy.
        /// delay + (initial * attempt) where attempt is 0-based.
        /// </summary>
        /// <param name="delay">The initial delay and delta to adjust initial by with each back-off.</param>
        /// <returns>
        /// A back-off strategy context.
        /// </returns>
        public static BackOffStrategy LinearBackOff(TimeSpan delay)
        {
            return new BackOffStrategy(
                attempt =>
                {
                    var factor = attempt * delay.TotalMilliseconds;
                    var totalDelay = delay.TotalMilliseconds + factor;

                    var sleepTime = ConstrainBounds(totalDelay);

                    return sleepTime;
                });
        }

        /// <summary>
        /// Begins an retriable operation using the progressive delay back-off strategy.
        /// delay * (attempt * scaleFactor) where attempt is 0-based.
        /// If attempt * scaleFactor is less than 1 then back-off becomes a constant delay equal to initial delay.
        /// </summary>
        /// <param name="initial">The initial delay.</param>
        /// <param name="scaleFactor">The scale factor. Defaults to 1.0.</param>
        /// <returns>
        /// A back-off strategy context.
        /// </returns>
        public static BackOffStrategy ProgressiveBackOff(TimeSpan initial, double scaleFactor = 1.0)
        {
            return new BackOffStrategy(
                attempt =>
                {
                    var factor = attempt * scaleFactor;
                    var safefactor = (factor < 1) ? 1 : factor;
                    var totalDelay = initial.TotalMilliseconds * safefactor;

                    var sleepTime = ConstrainBounds(totalDelay);

                    return sleepTime;
                });
        }

        /// <summary>
        /// Begins an retriable operation using the exponential delay back-off strategy.
        /// delay * (scaleFactor ^ attempt) where attempt is 0-based.
        /// If scaleFactor ^ attempt is less than 1 then back-off becomes a constant delay equal to initial delay.
        /// </summary>
        /// <param name="delay">The initial delay.</param>
        /// <param name="scaleFactor">The scale factor. Defaults to 2.0.</param>
        /// <returns>
        /// A back-off strategy context.
        /// </returns>
        public static BackOffStrategy ExponentialBackOff(TimeSpan delay, double scaleFactor = 2.0)
        {
            return new BackOffStrategy(
                attempt =>
                {
                    var factor = Math.Pow(scaleFactor, attempt);
                    var safefactor = (factor < 1) ? 1 : factor;
                    var totalDelay = delay.TotalMilliseconds * safefactor;

                    var sleepTime = ConstrainBounds(totalDelay);

                    return sleepTime;
                });
        }

        private static TimeSpan ConstrainBounds(double delay, double minimumBounds = 1, double maximumBounds = Double.MaxValue)
        {
            if (minimumBounds > maximumBounds)
            {
                throw new ArgumentException("minimumBounds cannot be greater than maximumBounds");
            }

            TimeSpan boundedTimeSpan;
            try
            {
                boundedTimeSpan = TimeSpan.FromMilliseconds(delay);
            }
            catch (OverflowException)
            {
                boundedTimeSpan = TimeSpan.MaxValue;
            }

            var lowBounded = Math.Max(minimumBounds, boundedTimeSpan.TotalMilliseconds);
            var bounded = Math.Min(maximumBounds, lowBounded);

            // This throws overflow exception: TimeSpan.FromMilliseconds(TimeSpan.MaxValue.TotalMilliseconds);
            // Therefore, must first construct the max value differently
            if (Math.Abs(TimeSpan.MaxValue.TotalMilliseconds - bounded) < 0.1)
            {
                return TimeSpan.MaxValue;
            }

            boundedTimeSpan = TimeSpan.FromMilliseconds(bounded);

            return boundedTimeSpan;
        }
    }
#if !SpritelyRecipesProject
#pragma warning restore 0436
#endif
}
